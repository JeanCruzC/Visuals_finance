# -*- coding: utf-8 -*-
"""App.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zQZ_FKlvf8FmIOJ342ABjBV-fZJgnPXW
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from dataclasses import dataclass
from datetime import datetime, date
import math

st.set_page_config(page_title="Finanzas Personales ‚Äî Dashboard", layout="wide")


# ----------------------------
# Helpers
# ----------------------------
def money(x, symbol="S/ "):
    if x is None or (isinstance(x, float) and np.isnan(x)):
        return f"{symbol}0.00"
    return f"{symbol}{x:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")

def safe_div(a, b):
    return float(a) / float(b) if b not in [0, 0.0, None] and not pd.isna(b) else 0.0

def get_period_series(dt_series, freq="M"):
    if freq == "W":
        return dt_series.dt.to_period("W").astype(str)
    elif freq == "M":
        return dt_series.dt.to_period("M").astype(str)
    elif freq == "Q":
        return dt_series.dt.to_period("Q").astype(str)
    elif freq == "Y":
        return dt_series.dt.to_period("Y").astype(str)
    return dt_series.dt.to_period("M").astype(str)

def ensure_datetime(df, col):
    if col in df.columns:
        df[col] = pd.to_datetime(df[col], errors="coerce")
    return df

def clamp(x, lo, hi):
    return max(lo, min(hi, x))

def hhi(shares):
    """Herfindahl-Hirschman Index for concentration."""
    s = np.array(shares, dtype=float)
    s = s[s > 0]
    if s.sum() == 0:
        return 1.0
    p = s / s.sum()
    return float(np.sum(p**2))


# ----------------------------
# Dynamic Recommendations Logic
# ----------------------------
def get_recommendations(ratios, dfm):
    recs = []
    
    # Savings
    sr = ratios['tasa_ahorro_global']
    if sr < 0.10:
        recs.append(("üî¥", "Ahorro Cr√≠tico", "Tu tasa de ahorro es muy baja (<10%). Revisa tus gastos fijos y cancela suscripciones no esenciales inmediatamente."))
    elif sr < 0.20:
        recs.append(("üü°", "Ahorro Mejorable", "Est√°s ahorrando, pero intenta llegar al 20%. Si ganas 1000, intenta guardar 200 en cuanto los recibas."))
    else:
        recs.append(("üü¢", "Ahorro S√≥lido", "¬°Excelente h√°bito de ahorro! Considera invertir el excedente para que no pierda valor por la inflaci√≥n."))

    # Liquidity / Emergency Fund
    liq = ratios['ratio_liquidez']
    if liq < 1:
        recs.append(("üî¥", "Peligro de Liquidez", "Tienes menos de 1 mes de gastos cubiertos. Prioridad #1: Construir un fondo de emergencia de al menos 1 mes."))
    elif liq < 3:
        recs.append(("üü°", "Fondo de Emergencia Bajo", "Tienes cobertura para poco tiempo. Apunta a tener 3 a 6 meses de gastos en una cuenta l√≠quida."))
    elif liq > 12:
        recs.append(("üîµ", "Exceso de Liquidez", "Tienes mucho dinero en efectivo (>12 meses). Podr√≠as estar perdiendo rentabilidad. Considera invertir una parte a largo plazo."))

    # Debt
    dti = ratios['ratio_deuda_ingresos']
    if dti > 0.40:
        recs.append(("üî¥", "Sobreendeudamiento", "Tus deudas son muy altas comparadas con tus ingresos. Det√©n el uso de tarjetas de cr√©dito y aplica el m√©todo Bola de Nieve."))
    elif dti > 0.30:
        recs.append(("üü°", "Deuda Elevada", "Destinas una parte importante de tu ingreso a deuda. Trata de prepagar capital para bajar la carga mensual."))

    return recs

# ----------------------------
# Data loading
# ----------------------------
REQUIRED_SHEETS = [
    "Datos_Maestros",
    "Ingresos",
    "Gastos_Fijos",
    "Gastos_Variables",
    "Deudas_Prestamos",
    "Pagos_Deudas",
    "Inversiones",
    "Cuentas_Bancarias",
    "Tarjetas_Credito",
    "Presupuesto_Mensual",
    "Metas_Financieras",
    "Movimientos_Consolidados",
]

@st.cache_data(show_spinner=False)
def load_excel(file) -> dict:
    xls = pd.ExcelFile(file)
    missing = [s for s in REQUIRED_SHEETS if s not in xls.sheet_names]
    if missing:
        raise ValueError(f"Faltan hojas en el Excel: {missing}")

    data = {}
    for s in REQUIRED_SHEETS:
        data[s] = pd.read_excel(xls, sheet_name=s)

    # Parse datetimes
    data["Ingresos"] = ensure_datetime(data["Ingresos"], "Fecha")
    data["Gastos_Fijos"] = ensure_datetime(data["Gastos_Fijos"], "Fecha_Cargo")
    data["Gastos_Variables"] = ensure_datetime(data["Gastos_Variables"], "Fecha")
    data["Pagos_Deudas"] = ensure_datetime(data["Pagos_Deudas"], "Fecha_Pago")
    data["Inversiones"] = ensure_datetime(data["Inversiones"], "Fecha_Inversi√≥n")
    data["Movimientos_Consolidados"] = ensure_datetime(data["Movimientos_Consolidados"], "Fecha")

    return data


# ----------------------------
# KPI computation core
# ----------------------------
@dataclass
class Assumptions:
    currency_symbol: str = "S/ "
    include_investments_in_cashflow: bool = False
    include_debt_payments_in_expenses: bool = True
    runway_include_debts: bool = True
    runway_include_investments: bool = False
    invest_liquidation_haircut: float = 0.7

    expected_return_annual: float = 0.08
    inflation_annual: float = 0.03
    swr: float = 0.04  # safe withdraw rate

    extra_debt_payment_monthly: float = 0.0

    # user entered "bienes" (assets non-liquid)
    bienes_value: float = 0.0

    # happiness / value (optional)
    happiness_scale: dict = None  # category -> 1..10 value
    value_scale: dict = None      # category -> 1..10 long-term value


def build_dynamic_table(data: dict, a: Assumptions, freq="M"):
    ingresos = data["Ingresos"].copy()
    gf = data["Gastos_Fijos"].copy()
    gv = data["Gastos_Variables"].copy()
    pagos = data["Pagos_Deudas"].copy()
    inv = data["Inversiones"].copy()
    mov = data["Movimientos_Consolidados"].copy()

    ingresos["Periodo"] = get_period_series(ingresos["Fecha"], freq)
    gf["Periodo"] = get_period_series(gf["Fecha_Cargo"], freq)
    gv["Periodo"] = get_period_series(gv["Fecha"], freq)
    pagos["Periodo"] = get_period_series(pagos["Fecha_Pago"], freq)
    inv["Periodo"] = get_period_series(inv["Fecha_Inversi√≥n"], freq)
    mov["Periodo"] = get_period_series(mov["Fecha"], freq)

    # Totals by Period
    income_m = ingresos.groupby("Periodo")["Monto_Neto"].sum().rename("Ingresos_Netos")
    fixed_m  = gf.groupby("Periodo")["Monto"].sum().rename("Gastos_Fijos")
    var_m    = gv.groupby("Periodo")["Monto"].sum().rename("Gastos_Variables")
    debt_m   = pagos.groupby("Periodo")["Monto_Total_Pagado"].sum().rename("Pagos_Deuda")
    inv_m    = inv.groupby("Periodo")["Monto_Invertido"].sum().rename("Inversiones_Outflow")

    # Ensure index union
    idx = pd.Index(sorted(set(income_m.index) | set(fixed_m.index) | set(var_m.index) | set(debt_m.index) | set(inv_m.index)))
    dfm = pd.DataFrame(index=idx)
    dfm["Ingresos_Netos"] = income_m.reindex(idx).fillna(0.0)
    dfm["Gastos_Fijos"]   = fixed_m.reindex(idx).fillna(0.0)
    dfm["Gastos_Variables"]= var_m.reindex(idx).fillna(0.0)
    dfm["Pagos_Deuda"]    = debt_m.reindex(idx).fillna(0.0)
    dfm["Inversiones_Outflow"]= inv_m.reindex(idx).fillna(0.0)

    # Expenses definition
    dfm["Gastos_Totales"] = dfm["Gastos_Fijos"] + dfm["Gastos_Variables"]
    if a.include_debt_payments_in_expenses:
        dfm["Gastos_Totales"] += dfm["Pagos_Deuda"]
    if a.include_investments_in_cashflow:
        dfm["Gastos_Totales"] += dfm["Inversiones_Outflow"]

    dfm["Flujo_Neto"] = dfm["Ingresos_Netos"] - dfm["Gastos_Totales"]
    dfm["Tasa_Ahorro"] = dfm.apply(lambda r: safe_div(r["Flujo_Neto"], r["Ingresos_Netos"]), axis=1)

    # EBITDA Personal (adaptado)
    # Ingresos operativos = salario + recurrentes
    ingresos_oper = ingresos.loc[
        (ingresos["Categor√≠a"].astype(str).str.lower().str.contains("salario")) |
        (ingresos["Es_Recurrente"].astype(str).str.lower() == "s√≠")
    ].copy()
    ingresos_oper_m = ingresos_oper.groupby("Periodo")["Monto_Neto"].sum().rename("Ingresos_Operativos")

    # Gastos operativos esenciales = fijos esenciales + variables necesarias
    gf_ess = gf.loc[gf.get("Es_Esencial", "").astype(str).str.lower() == "s√≠"].copy()
    gv_ess = gv.loc[gv.get("Es_Necesario", "").astype(str).str.lower() == "s√≠"].copy()
    opex_m = (gf_ess.groupby("Periodo")["Monto"].sum() + gv_ess.groupby("Periodo")["Monto"].sum()).rename("Opex_Esencial")

    dfm["Ingresos_Operativos"] = ingresos_oper_m.reindex(idx).fillna(0.0)
    dfm["Opex_Esencial"] = opex_m.reindex(idx).fillna(0.0)
    dfm["EBITDA_Personal"] = dfm["Ingresos_Operativos"] - dfm["Opex_Esencial"]

    # Personal Free Cash Flow: net income - essential opex - capex personal
    # CapEx personal: Educaci√≥n + Salud (variables) + (opcional) "Hogar/Mascota" en Otros
    capex = gv.loc[gv["Categor√≠a"].isin(["Educaci√≥n","Salud"])].copy()
    capex_m = capex.groupby("Periodo")["Monto"].sum().rename("CapEx_Personal")
    dfm["CapEx_Personal"] = capex_m.reindex(idx).fillna(0.0)
    dfm["FCF_Personal"] = dfm["Ingresos_Netos"] - dfm["Opex_Esencial"] - dfm["CapEx_Personal"]

    # Budget adherence (planned vs actual): use Presupuesto_Mensual sheet
    # NOTE: Presupuesto is usually monthly. If freq != 'M', this might be tricky.
    # For now, we will try to map it if freq is M, otherwise fill 0 or skip.
    pres = data["Presupuesto_Mensual"].copy()
    if freq == "M":
        pres["Periodo"] = pres["Mes_A√±o"].astype(str)
        planned_m = pres.groupby("Periodo")["Presupuesto_Planeado"].sum().rename("Presupuesto_Planeado_Total")
        actual_m  = pres.groupby("Periodo")["Gasto_Real"].sum().rename("Presupuesto_Gasto_Real_Total")
        dfm["Presupuesto_Planeado_Total"] = planned_m.reindex(idx).fillna(0.0)
        dfm["Presupuesto_Gasto_Real_Total"] = actual_m.reindex(idx).fillna(0.0)
        dfm["Budget_Adherence"] = dfm.apply(lambda r: 1 - safe_div(abs(r["Presupuesto_Gasto_Real_Total"]-r["Presupuesto_Planeado_Total"]), r["Presupuesto_Planeado_Total"]), axis=1)
        dfm["Budget_Adherence"] = dfm["Budget_Adherence"].clip(lower=0, upper=1)
    else:
        dfm["Presupuesto_Planeado_Total"] = 0.0
        dfm["Presupuesto_Gasto_Real_Total"] = 0.0
        dfm["Budget_Adherence"] = 0.5 # Neutral if not monthly

    return dfm.reset_index().rename(columns={"index":"Mes"}), mov, ingresos, gf, gv, pagos, inv


def compute_ratios_and_balance(data: dict, dfm: pd.DataFrame, a: Assumptions):
    dm = data["Datos_Maestros"].iloc[0].to_dict()
    cuentas = data["Cuentas_Bancarias"].copy()
    tarjetas = data["Tarjetas_Credito"].copy()
    deudas = data["Deudas_Prestamos"].copy()
    inv = data["Inversiones"].copy()

    # Liquidity / assets
    activos_liquidos = float(cuentas["Saldo_Actual"].sum())
    inversiones_valor = float(inv["Valor_Actual"].sum()) if "Valor_Actual" in inv.columns else 0.0
    activos_totales = activos_liquidos + inversiones_valor + float(a.bienes_value)

    # Liabilities
    pasivos_deudas = float(deudas["Saldo_Actual"].sum()) if "Saldo_Actual" in deudas.columns else 0.0
    pasivos_tarjetas = float(tarjetas["Saldo_Actual"].sum()) if "Saldo_Actual" in tarjetas.columns else 0.0
    pasivos_totales = pasivos_deudas + pasivos_tarjetas

    patrimonio_neto_actual = activos_totales - pasivos_totales

    # Annualized income (net)
    total_income = float(dfm["Ingresos_Netos"].sum())
    months = max(1, dfm["Mes"].nunique())
    ingreso_mensual_prom = total_income / months
    ingreso_anual_estimado = ingreso_mensual_prom * 12

    # Average monthly expenses
    gasto_mensual_prom = float(dfm["Gastos_Totales"].mean()) if len(dfm) else 0.0

    # Ratios
    ratio_deuda_ingresos = safe_div(pasivos_totales, ingreso_anual_estimado)
    ratio_liquidez = safe_div(activos_liquidos, gasto_mensual_prom)
    tasa_ahorro_global = safe_div(dfm["Flujo_Neto"].sum(), dfm["Ingresos_Netos"].sum())
    ratio_gastos_fijos = safe_div(dfm["Gastos_Fijos"].sum(), dfm["Ingresos_Netos"].sum())

    limite_total = float(tarjetas["L√≠mite_Cr√©dito"].sum()) if "L√≠mite_Cr√©dito" in tarjetas.columns else 0.0
    util_credito = safe_div(pasivos_tarjetas, limite_total)

    # Passive income & FI Index
    ing = data["Ingresos"].copy()
    passive = ing.loc[ing["Categor√≠a"].astype(str).str.lower().isin(["inversiones","rentas"])].copy()
    passive_monthly = float(passive["Monto_Neto"].sum()) / months if months else 0.0
    fi_index = safe_div(passive_monthly, gasto_mensual_prom) * 100

    # Emergency fund progress
    fondo_obj = float(dm.get("Fondo_Emergencia_Objetivo", 0.0))
    emergencia_pct = safe_div(activos_liquidos, fondo_obj)

    return {
        "activos_liquidos": activos_liquidos,
        "inversiones_valor": inversiones_valor,
        "activos_totales": activos_totales,
        "pasivos_deudas": pasivos_deudas,
        "pasivos_tarjetas": pasivos_tarjetas,
        "pasivos_totales": pasivos_totales,
        "patrimonio_neto_actual": patrimonio_neto_actual,
        "ratio_deuda_ingresos": ratio_deuda_ingresos,
        "ratio_liquidez": ratio_liquidez,
        "tasa_ahorro_global": tasa_ahorro_global,
        "ratio_gastos_fijos": ratio_gastos_fijos,
        "util_credito": util_credito,
        "ingreso_anual_estimado": ingreso_anual_estimado,
        "gasto_mensual_prom": gasto_mensual_prom,
        "passive_monthly": passive_monthly,
        "fi_index": fi_index,
        "fondo_obj": fondo_obj,
        "emergencia_pct": emergencia_pct,
    }


# ----------------------------
# Debt strategy simulation
# ----------------------------
def build_debt_universe(data: dict):
    """Unify Deudas_Prestamos + Tarjetas_Credito as debts."""
    deudas = data["Deudas_Prestamos"].copy()
    tarjetas = data["Tarjetas_Credito"].copy()

    debts = []

    # Loans
    for _, r in deudas.iterrows():
        debts.append({
            "id": str(r["ID_Deuda"]),
            "name": f"{r.get('Tipo','Deuda')} ‚Äî {r.get('Acreedor','')}".strip(),
            "balance": float(r.get("Saldo_Actual", 0.0)),
            "rate_monthly": float(r.get("Tasa_Inter√©s_Anual", 0.0)) / 12.0,
            "min_payment": float(r.get("Cuota_Mensual", 0.0)),
            "kind": "loan"
        })

    # Credit cards
    for _, r in tarjetas.iterrows():
        debts.append({
            "id": str(r["ID_Tarjeta"]),
            "name": f"Tarjeta {r.get('Banco_Emisor','')} ‚Ä¢{r.get('√öltimos_4_D√≠gitos','')}".strip(),
            "balance": float(r.get("Saldo_Actual", 0.0)),
            "rate_monthly": float(r.get("Tasa_Inter√©s_Mensual", 0.0)),
            "min_payment": float(r.get("Pago_M√≠nimo", 0.0)),
            "kind": "card"
        })

    debts = [d for d in debts if d["balance"] > 0]
    return debts


def simulate_payoff(debts, extra_payment=0.0, strategy="avalanche", max_months=600):
    """
    strategies:
      - avalanche: extra to highest rate
      - snowball: extra to smallest balance
      - hybrid: weighted (0.6 interest, 0.4 balance)
    Returns schedule df + totals
    """
    debts = [d.copy() for d in debts]
    month = 0
    schedule = []
    total_interest = 0.0

    while month < max_months and any(d["balance"] > 0.01 for d in debts):
        month += 1

        # accrue interest
        for d in debts:
            if d["balance"] <= 0:
                continue
            interest = d["balance"] * d["rate_monthly"]
            total_interest += interest
            d["balance"] += interest

        # pay minimums first
        cash = extra_payment
        for d in debts:
            if d["balance"] <= 0:
                continue
            pay = min(d["min_payment"], d["balance"])
            d["balance"] -= pay
            schedule.append({"month": month, "debt_id": d["id"], "debt_name": d["name"], "payment": pay, "type": "min"})
        # choose target for extra
        alive = [d for d in debts if d["balance"] > 0.01]
        if alive and cash > 0:
            if strategy == "avalanche":
                target = max(alive, key=lambda x: x["rate_monthly"])
            elif strategy == "snowball":
                target = min(alive, key=lambda x: x["balance"])
            else:  # hybrid
                # normalize
                rates = np.array([x["rate_monthly"] for x in alive], float)
                bals  = np.array([x["balance"] for x in alive], float)
                r_norm = (rates - rates.min()) / (rates.max() - rates.min() + 1e-9)
                b_norm = (bals - bals.min()) / (bals.max() - bals.min() + 1e-9)
                score = 0.6 * r_norm + 0.4 * (1 - b_norm)  # prefer high rate + smaller balance a bit
                target = alive[int(np.argmax(score))]

            pay = min(cash, target["balance"])
            target["balance"] -= pay
            schedule.append({"month": month, "debt_id": target["id"], "debt_name": target["name"], "payment": pay, "type": "extra"})

        # snapshot balances end of month
        for d in debts:
            schedule.append({"month": month, "debt_id": d["id"], "debt_name": d["name"], "payment": 0.0, "type": "balance", "balance_end": max(0.0, d["balance"])})

    sch = pd.DataFrame(schedule)
    payoff_months = month
    return sch, total_interest, payoff_months


# ----------------------------
# Scores (0-1000) and advanced analytics
# ----------------------------
def compute_health_score(dfm, ratios, data: dict):
    """
    0-1000:
    - Savings rate (20%)
    - Income diversification (15%)
    - Debt burden (20%)
    - Emergency fund (15%)
    - Net worth growth (15%)
    - Planning / budget adherence (10%)
    - Financial education proxy (5%)
    """
    # Savings
    savings = clamp((ratios["tasa_ahorro_global"] + 0.2) / 0.4, 0, 1)  # -20%..+20% => 0..1
    # Diversification: 1 - HHI by income categories
    ing = data["Ingresos"].copy()
    shares = ing.groupby("Categor√≠a")["Monto_Neto"].sum().values
    div = clamp(1 - hhi(shares), 0, 1)
    # Debt burden: debt payments / income
    debt_burden = safe_div(dfm["Pagos_Deuda"].sum(), dfm["Ingresos_Netos"].sum()) if "Pagos_Deuda" in dfm else 0.0
    debt_score = clamp(1 - debt_burden / 0.35, 0, 1)  # >35% penaliza fuerte
    # Emergency coverage in months (liquid / avg monthly expenses)
    emer = clamp(ratios["ratio_liquidez"] / 6.0, 0, 1)  # 6 meses ideal
    # Net worth trend: sign of flujo neto rolling
    trend = 0.5
    if len(dfm) >= 3:
        x = dfm["Flujo_Neto"].rolling(3).mean().iloc[-1]
        trend = clamp((x / max(1, dfm["Ingresos_Netos"].mean())) * 5 + 0.5, 0, 1)  # heur√≠stico
    # Planning: budget adherence
    plan = float(dfm["Budget_Adherence"].mean()) if "Budget_Adherence" in dfm else 0.5
    # Education proxy: % spend on educaci√≥n up to 10% => full score (heur√≠stico)
    gv = data["Gastos_Variables"].copy()
    edu = gv.loc[gv["Categor√≠a"] == "Educaci√≥n", "Monto"].sum()
    total_spend = (dfm["Gastos_Fijos"].sum() + dfm["Gastos_Variables"].sum() + dfm["Pagos_Deuda"].sum())
    edu_ratio = safe_div(edu, total_spend)
    edu_score = clamp(edu_ratio / 0.10, 0, 1)

    weights = {"savings":0.20,"div":0.15,"debt":0.20,"emer":0.15,"trend":0.15,"plan":0.10,"edu":0.05}
    total = (
        savings*weights["savings"] + div*weights["div"] + debt_score*weights["debt"] +
        emer*weights["emer"] + trend*weights["trend"] + plan*weights["plan"] + edu_score*weights["edu"]
    )
    return int(round(total * 1000))


def compute_runway(ratios, dfm, a: Assumptions):
    liquid = ratios["activos_liquidos"]
    burn_normal = ratios["gasto_mensual_prom"]
    # survival burn = essential opex
    burn_survival = float(dfm["Opex_Esencial"].mean()) if "Opex_Esencial" in dfm and len(dfm) else burn_normal

    runway_normal = safe_div(liquid, burn_normal)
    runway_survival = safe_div(liquid, burn_survival)

    # with liquidation of investments (haircut)
    invest_liq = ratios["inversiones_valor"] * a.invest_liquidation_haircut
    runway_with_liq = safe_div(liquid + invest_liq, burn_normal)

    return runway_normal, runway_survival, runway_with_liq, burn_normal, burn_survival


def compute_money_velocity(mov: pd.DataFrame, ingresos: pd.DataFrame, freq="M"):
    """
    Money Velocity:
    velocity = ingresos_mensuales / d√≠as hasta gastar 50% del ingreso
    """
    mov = mov.copy()
    mov["Fecha"] = pd.to_datetime(mov["Fecha"])
    mov["Periodo"] = get_period_series(mov["Fecha"], freq)
    ingresos = ingresos.copy()
    ingresos["Periodo"] = get_period_series(ingresos["Fecha"], freq)

    results = []
    for per in sorted(mov["Periodo"].unique()):
        inc = ingresos.loc[ingresos["Periodo"] == per, "Monto_Neto"].sum()
        if inc <= 0:
            continue
        half = 0.5 * inc

        m = mov.loc[mov["Periodo"] == per].copy()
        # expenses = negative amounts
        m = m.sort_values("Fecha")
        m["Gasto_Pos"] = (-m["Monto"]).clip(lower=0)
        m["CumGasto"] = m["Gasto_Pos"].cumsum()

        hit = m.loc[m["CumGasto"] >= half]
        if hit.empty:
            continue
        hit_dt = hit.iloc[0]["Fecha"]
        first_dt = m.iloc[0]["Fecha"]
        days = max(1.0, (hit_dt - first_dt).total_seconds() / 86400.0)

        vel = safe_div(inc, days)
        results.append({
            "Periodo": per,
            "Ingreso_Periodo": inc,
            "Dias_hasta_50pct": days,
            "Velocidad": vel,
            "Fecha_50pct": hit_dt
        })
    return pd.DataFrame(results)


def opportunity_cost_table(gv: pd.DataFrame, rate_annual=0.08, years=10, threshold=200.0):
    gv = gv.copy()
    gv = gv.loc[gv["Monto"] >= threshold].copy()
    if gv.empty:
        return gv.assign(Costo_Oportunidad=0.0)

    r = rate_annual
    fv_mult = (1 + r) ** years
    gv["Costo_Oportunidad"] = gv["Monto"] * fv_mult - gv["Monto"]
    gv["Valor_Futuro"] = gv["Monto"] * fv_mult
    return gv.sort_values("Monto", ascending=False)


def net_worth_by_month(data: dict, dfm: pd.DataFrame, a: Assumptions, freq="M"):
    """
    Approx net worth over time (dynamic periodicity):
    - Cash: use last Saldo_Acumulado from Movimientos per period
    - Investments: sum of lots purchased up to period end
    """
    mov = data["Movimientos_Consolidados"].copy()
    mov["Fecha"] = pd.to_datetime(mov["Fecha"])
    mov["Periodo"] = get_period_series(mov["Fecha"], freq)

    # Cash end-of-period from Saldo_Acumulado
    cash_m = mov.sort_values("Fecha").groupby("Periodo")["Saldo_Acumulado"].last()

    inv = data["Inversiones"].copy()
    inv["Fecha_Inversi√≥n"] = pd.to_datetime(inv["Fecha_Inversi√≥n"])
    inv["Periodo"] = get_period_series(inv["Fecha_Inversi√≥n"], freq)
    # Approx: for each period, include all investments up to that period
    inv = inv.sort_values("Fecha_Inversi√≥n")
    periods = sorted(dfm["Mes"].unique()) # dfm["Mes"] is actually Periodo now
    inv_val_m = {}
    for p in periods:
        inv_val_m[p] = float(inv.loc[inv["Periodo"] <= p, "Valor_Actual"].sum()) if "Valor_Actual" in inv.columns else 0.0
    inv_val_m = pd.Series(inv_val_m)

    # Liabilities loans by month (using payments schedule)
    deudas = data["Deudas_Prestamos"].copy()
    pagos = data["Pagos_Deudas"].copy()
    pagos["Fecha_Pago"] = pd.to_datetime(pagos["Fecha_Pago"])
    pagos["Periodo"] = get_period_series(pagos["Fecha_Pago"], freq)

    # start with current saldo as fallback
    current_saldo = deudas.set_index("ID_Deuda")["Saldo_Actual"].to_dict() if "Saldo_Actual" in deudas.columns else {}
    loans_m = {}
    for p in periods:
        # debt balance approx = min saldo_after for payments up to period, else initial current_saldo
        bal = 0.0
        for debt_id, cur in current_saldo.items():
            paid = pagos.loc[(pagos["ID_Deuda"] == debt_id) & (pagos["Periodo"] <= p)]
            if not paid.empty and "Saldo_Despu√©s_Pago" in paid.columns:
                b = float(paid.sort_values("Fecha_Pago")["Saldo_Despu√©s_Pago"].iloc[-1])
            else:
                b = float(cur)
            bal += max(0.0, b)
        loans_m[p] = bal
    loans_m = pd.Series(loans_m)

    cards = data["Tarjetas_Credito"].copy()
    cards_balance = float(cards["Saldo_Actual"].sum()) if "Saldo_Actual" in cards.columns else 0.0

    assets = (cash_m.reindex(periods).fillna(method="ffill").fillna(0.0) +
              inv_val_m.reindex(periods).fillna(0.0) +
              float(a.bienes_value))

    liabilities = loans_m.reindex(periods).fillna(0.0) + cards_balance
    net = assets - liabilities

    out = pd.DataFrame({
        "Mes": periods,
        "Activos_Caja": cash_m.reindex(periods).fillna(method="ffill").fillna(0.0).values,
        "Activos_Inversiones": inv_val_m.reindex(periods).fillna(0.0).values,
        "Activos_Bienes": float(a.bienes_value),
        "Pasivos_Deudas": loans_m.reindex(periods).fillna(0.0).values,
        "Pasivos_Tarjetas": cards_balance,
        "Patrimonio_Neto": net.values
    })
    return out


def forecast_net_worth(nw_df: pd.DataFrame, base_savings_monthly: float, years=5, a: Assumptions = None):
    """
    Simple projection:
    - Base: savings stays constant and grows at expected return on investments chunk.
    - Optimistic: +20% income => +20% savings
    - Pessimistic: -20% income => -20% savings (floored)
    """
    a = a or Assumptions()
    last = float(nw_df["Patrimonio_Neto"].iloc[-1]) if len(nw_df) else 0.0
    months = int(years * 12)
    t = np.arange(0, months+1)
    r_m = (1 + a.expected_return_annual) ** (1/12) - 1

    def proj(sav_mult):
        s = max(-1e9, base_savings_monthly * sav_mult)
        values = [last]
        v = last
        for i in range(months):
            # add savings then grow
            v = (v + s) * (1 + r_m)
            values.append(v)
        return values

    out = pd.DataFrame({
        "Mes_Futuro": t,
        "Base": proj(1.0),
        "Optimista": proj(1.2),
        "Pesimista": proj(0.8),
    })
    return out


# ----------------------------
# UI
# ----------------------------
st.title("Finanzas Personales ‚Äî Dashboard & KPIs")
st.caption("Herramienta para an√°lisis financiero personal con KPIs, deuda, runway, scores y proyecciones.")

with st.sidebar:
    st.header("Configuraci√≥n")
    uploaded = st.file_uploader("Sube tu Excel (Finanzas_Personales_Analisis_Horario.xlsx)", type=["xlsx"])

    currency_symbol = st.text_input("S√≠mbolo moneda", value="S/ ", help="El s√≠mbolo que se mostrar√° junto a los montos (ej. $, ‚Ç¨, S/).")
    include_investments_in_cashflow = st.toggle("Incluir inversiones en 'Gastos Totales'", value=False, help="Si activas esto, el dinero que inviertes se contar√° como un gasto en tus reportes.")
    include_debt_payments_in_expenses = st.toggle("Incluir pagos de deuda en 'Gastos Totales'", value=True, help="Si activas esto, los pagos de tus deudas se contar√°n como gastos.")

    with st.expander("Configuraci√≥n Avanzada (Opcional)"):
        st.caption("Ajusta estos valores si tienes conocimientos financieros m√°s avanzados.")
        
        st.subheader("Supuestos Macroecon√≥micos")
        expected_return = st.slider("Retorno esperado anual", 0.0, 0.30, 0.08, 0.005, help="Cu√°nto esperas ganar anualmente con tus inversiones (promedio).")
        inflation = st.slider("Inflaci√≥n anual", 0.0, 0.20, 0.03, 0.005, help="Cu√°nto suben los precios cada a√±o (promedio).")
        swr = st.slider("Safe Withdraw Rate (Retiro Seguro)", 0.02, 0.06, 0.04, 0.005, help="Porcentaje de tu portafolio que puedes gastar anualmente en tu jubilaci√≥n sin que se acabe el dinero.")
        
        st.subheader("Activos y Runway")
        bienes = st.number_input("Valor de Bienes (Casa, Auto, etc.)", min_value=0.0, value=0.0, step=500.0, help="Valor estimado de tus activos f√≠sicos que podr√≠as vender si fuera necesario.")
        haircut = st.slider("Castigo por liquidaci√≥n r√°pida", 0.0, 1.0, 0.70, 0.05, help="Si tuvieras que vender tus inversiones hoy mismo por emergencia, ¬øqu√© porcentaje del valor recuperar√≠as? (0.70 = 70%)")
        runway_invest = st.toggle("Incluir inversiones en Runway", value=False, help="Considerar tus inversiones (con el castigo aplicado) como parte de tu fondo de emergencia.")

        st.subheader("Deuda ‚Äî Pago Extra")
        extra_debt = st.number_input("Pago extra mensual a deudas", min_value=0.0, value=0.0, step=50.0, help="Dinero adicional que puedes destinar cada mes para pagar tus deudas m√°s r√°pido.")

        st.subheader("An√°lisis de Costo de Oportunidad")
        oc_years = st.slider("A√±os a proyectar", 1, 30, 10, 1, help="Cu√°ntos a√±os en el futuro quieres ver el impacto de tus gastos.")
        oc_threshold = st.number_input("Umbral de gasto grande", min_value=0.0, value=200.0, step=50.0, help="Considerar como 'gasto grande' cualquier monto mayor a este.")


if not uploaded:
    st.info("Asesor: sube el Excel para empezar.")
    st.stop()

# Load
try:
    data = load_excel(uploaded)
except Exception as e:
    st.error(f"Asesor: no pude cargar el Excel. Detalle: {e}")
    st.stop()

ass = Assumptions(
    currency_symbol=currency_symbol,
    include_investments_in_cashflow=include_investments_in_cashflow,
    include_debt_payments_in_expenses=include_debt_payments_in_expenses,
    expected_return_annual=expected_return,
    inflation_annual=inflation,
    swr=swr,
    extra_debt_payment_monthly=extra_debt,
    bienes_value=bienes,
    invest_liquidation_haircut=haircut,
    runway_include_investments=runway_invest
)

# Periodicity Selector
st.sidebar.divider()
st.sidebar.header("üìÖ Periodo de An√°lisis")
period_map = {"Mensual": "M", "Semanal": "W", "Trimestral": "Q", "Anual": "Y"}
period_sel = st.sidebar.selectbox("Agrupaci√≥n de Datos", list(period_map.keys()), index=0)
freq_code = period_map[period_sel]

dfm, mov, ingresos, gf, gv, pagos, inv = build_dynamic_table(data, ass, freq=freq_code)

# ----------------------------
# Global Date Filter
# ----------------------------
all_months = sorted(dfm["Mes"].unique())
if not all_months:
    st.warning("No hay datos suficientes para generar el dashboard.")
    st.stop()

start_month, end_month = st.sidebar.select_slider(
    "Selecciona rango:",
    options=all_months,
    value=(all_months[0], all_months[-1])
)

# Filter DataFrames based on selection
dfm_full = dfm.copy() # Keep full for some specific long-term charts if needed, but mostly we use filtered
dfm = dfm.loc[(dfm["Mes"] >= start_month) & (dfm["Mes"] <= end_month)].copy()

# Filter other DFs for consistency in advanced charts if they rely on them
# (Note: Some functions below take 'data' dict which is raw. 
# Ideally we should filter 'data' too, but that's complex as it has many sheets.
# For now, we focus on 'dfm' which drives most KPIs. 
# We will pass 'start_month' and 'end_month' to specific charts if needed.)

ratios = compute_ratios_and_balance(data, dfm, ass) # Re-compute ratios based on filtered dfm (income/expenses)
# Note: Balance sheet items (Assets/Liabilities) are usually "current" (snapshot), 
# but 'compute_ratios' uses 'dfm' for flows (savings rate, etc.). 
# So Ratios will now reflect the performance *during the selected period*.

health_score = compute_health_score(dfm, ratios, data)
runway_normal, runway_survival, runway_with_liq, burn_normal, burn_survival = compute_runway(ratios, dfm, ass)


# Money velocity
mv_df = compute_money_velocity(mov, ingresos, freq=freq_code)

# Net worth series + forecast
nw_df = net_worth_by_month(data, dfm, ass, freq=freq_code)
base_sav = float(dfm["Flujo_Neto"].tail(3).mean()) if len(dfm) else 0.0
forecast_df = forecast_net_worth(nw_df, base_sav, years=5, a=ass)

# Debt simulations
debts_universe = build_debt_universe(data)
sch_av, int_av, months_av = simulate_payoff(debts_universe, extra_payment=ass.extra_debt_payment_monthly, strategy="avalanche")
sch_sn, int_sn, months_sn = simulate_payoff(debts_universe, extra_payment=ass.extra_debt_payment_monthly, strategy="snowball")
sch_hy, int_hy, months_hy = simulate_payoff(debts_universe, extra_payment=ass.extra_debt_payment_monthly, strategy="hybrid")

# Opportunity cost
oc_tbl = opportunity_cost_table(gv, rate_annual=ass.expected_return_annual, years=oc_years, threshold=oc_threshold)


# ----------------------------
# Top KPIs row
# ----------------------------
c1, c2, c3, c4, c5 = st.columns(5)

c1.metric("Patrimonio Neto (actual)", money(ratios["patrimonio_neto_actual"], ass.currency_symbol))
c2.metric("Tasa de Ahorro (global)", f"{ratios['tasa_ahorro_global']*100:.1f}%")
c3.metric("Liquidez (meses)", f"{ratios['ratio_liquidez']:.1f}")
c4.metric("Deuda/Ingresos (anual)", f"{ratios['ratio_deuda_ingresos']*100:.1f}%")
c5.metric("Health Score (0-1000)", f"{health_score}")

st.divider()


# ----------------------------
# Tabs
# ----------------------------
tab0, tab1, tab2, tab3, tab4, tab6, tab7 = st.tabs([
    "üë∂ Resumen Financiero",
    "üìå Dashboard Principal",
    "üí∏ Flujo de Caja",
    "üè¶ Patrimonio y Ratios",
    "üí≥ Deudas",
    "üîÆ Proyecciones",
    "üìò Glosario"
])

# ----------------------------
# Micro-Insights Helper
# ----------------------------
def get_insight(metric, value, target=None):
    """Returns a short, actionable micro-insight."""
    if metric == "Savings Rate":
        if value < 0.1: return "‚ö†Ô∏è Cr√≠tico: Intenta ahorrar al menos 1% este mes."
        if value < 0.2: return "üí° Tip: Sube tu ahorro en 5% reduciendo gastos hormiga."
        return "‚úÖ Tip: ¬°Vas genial! Considera invertir el excedente."
    elif metric == "Liquidity":
        if value < 1: return "‚ö†Ô∏è Alerta: Fondo de emergencia muy bajo."
        if value > 12: return "üí° Tip: Tienes mucho efectivo, ¬øquiz√°s invertir?"
        return "‚úÖ Tip: Tu liquidez es saludable."
    elif metric == "Debt Ratio":
        if value > 0.4: return "‚ö†Ô∏è Alerta: Deuda peligrosa. Prioriza pagar."
        return "‚úÖ Tip: Nivel de deuda manejable."
    elif metric == "Expenses":
        return "üí° Tip: Revisa tus gastos fijos, suelen ser los m√°s dif√≠ciles de bajar."
    return ""

# ----------------------------
# Tab 0 ‚Äî Resumen Simple (Nuevo)
# ----------------------------
with tab0:
    st.header("Resumen Financiero")
    
    # 1. Sem√°foro Financiero
    st.subheader("Estado de Salud Financiera")
    
    savings_rate = ratios['tasa_ahorro_global']
    if savings_rate >= 0.20:
        st.success("**Excelente**: Est√°s ahorrando m√°s del 20% de tus ingresos. Mant√©n este h√°bito para asegurar tu futuro financiero.")
    elif savings_rate > 0:
        st.warning("**Bueno**: Est√°s generando ahorro, pero por debajo del 20% recomendado. Revisa gastos discrecionales para mejorar este margen.")
    else:
        st.error("**Atenci√≥n**: Tus gastos superan a tus ingresos. Es cr√≠tico revisar tu presupuesto y reducir gastos no esenciales.")
    st.caption(get_insight("Savings Rate", savings_rate))

    # 2. N√∫meros Grandes
    st.subheader("Indicadores Principales")
    c1, c2, c3 = st.columns(3)
    c1.metric("Ingresos Totales", money(dfm["Ingresos_Netos"].sum(), ass.currency_symbol))
    c2.metric("Gastos Totales", money(dfm["Gastos_Totales"].sum(), ass.currency_symbol), help=get_insight("Expenses", 0))
    c3.metric("Ahorro Neto", money(dfm["Flujo_Neto"].sum(), ass.currency_symbol))

    # 3. Gr√°fico Simple (Torta)
    st.subheader("Distribuci√≥n del Gasto")
    
    # Simplificar categor√≠as para el gr√°fico
    simple_data = pd.DataFrame({
        "Tipo": ["Gastos Fijos (Necesidades)", "Gastos Variables (Deseos)", "Ahorro"],
        "Monto": [dfm["Gastos_Fijos"].sum(), dfm["Gastos_Variables"].sum(), dfm["Flujo_Neto"].sum()]
    })
    # Filtrar negativos en ahorro para el gr√°fico
    simple_data["Monto"] = simple_data["Monto"].clip(lower=0)
    
    fig_simple = px.pie(simple_data, names="Tipo", values="Monto", title="Distribuci√≥n de Ingresos", hole=0.4)
    fig_simple.update_traces(textposition='inside', textinfo='percent+label')
    st.plotly_chart(fig_simple, use_container_width=True)
    st.caption("üí° Tip: La regla ideal es 50% Necesidades, 30% Deseos, 20% Ahorro.")

    # 4. Explicaci√≥n
    with st.expander("Interpretaci√≥n del Modelo", expanded=True):
        st.markdown("""
        **Regla 50/30/20 (Referencia):**
        Una estructura financiera saludable sugiere distribuir tus ingresos de la siguiente manera:
        
        *   **50% Necesidades (Gastos Fijos):** Pagos ineludibles como vivienda, servicios y alimentaci√≥n b√°sica.
        *   **30% Deseos (Gastos Variables):** Gastos discrecionales como entretenimiento, salidas y compras personales.
        *   **20% Ahorro e Inversi√≥n:** Dinero reservado para metas futuras, fondo de emergencia y retiro.
        
        Utiliza este gr√°fico para comparar tu distribuci√≥n actual con este modelo ideal.
        """)

# ----------------------------
# Tab 1 ‚Äî Dashboard
# ----------------------------
with tab1:
    with st.expander("Conceptos Clave"):
        st.write("Este es tu **Panel de Control**. Aqu√≠ ves un resumen r√°pido de todo. Lo m√°s importante es el gr√°fico de 'Cascada' que muestra c√≥mo entra tu dinero y c√≥mo se va reduciendo con cada gasto hasta llegar a lo que te sobra.")
    st.subheader("Dashboard principal")

    # Waterfall: Ingresos vs Gastos (Periodo Seleccionado)
    # Aggregate over the filtered period
    wf_ing = dfm["Ingresos_Netos"].sum()
    wf_gf = -dfm["Gastos_Fijos"].sum()
    wf_gv = -dfm["Gastos_Variables"].sum()
    wf_debt = -dfm["Pagos_Deuda"].sum()
    wf_inv = -dfm["Inversiones_Outflow"].sum() if ass.include_investments_in_cashflow else 0
    wf_net = dfm["Flujo_Neto"].sum()
    
    wf = go.Figure(go.Waterfall(
        x=["Ingresos", "Gastos Fijos", "Gastos Variables", "Pagos Deuda", "Inversiones", "Flujo Neto"],
        y=[wf_ing, wf_gf, wf_gv, wf_debt, wf_inv, wf_net],
        measure=["relative","relative","relative","relative","relative","total"],
        text=[money(x, ass.currency_symbol) for x in [wf_ing, wf_gf, wf_gv, wf_debt, wf_inv, wf_net]],
        textposition="outside"
    ))
    
    period_label = f"{start_month} a {end_month}" if start_month != end_month else start_month
    wf.update_layout(title=f"Cascada de Flujo ‚Äî {period_label}", height=380, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(wf, use_container_width=True)
    st.caption("üí° Tip: Si la barra final (Flujo Neto) es roja o muy peque√±a, revisa tus Gastos Variables.")

    # Area: Ingresos vs Gastos
    area_df = dfm[["Mes","Ingresos_Netos","Gastos_Totales"]].copy()
    area_df = area_df.melt(id_vars="Mes", var_name="Tipo", value_name="Monto")
    fig_area = px.area(area_df, x="Mes", y="Monto", color="Tipo", title="Ingresos vs Gastos (temporal)")
    fig_area.update_layout(height=360, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_area, use_container_width=True)

    # Gauge ratios
    g1, g2, g3 = st.columns(3)

    util = ratios["util_credito"]
    fig_g1 = go.Figure(go.Indicator(
        mode="gauge+number",
        value=util*100,
        title={"text":"Utilizaci√≥n de cr√©dito (%)"},
        gauge={"axis":{"range":[0,100]}, "bar":{"color":"#444"}}
    ))
    fig_g1.update_layout(height=260, margin=dict(l=10,r=10,t=40,b=10))
    g1.plotly_chart(fig_g1, use_container_width=True)
    g1.caption(get_insight("Debt Ratio", util)) # Reusing debt ratio logic roughly

    fig_g2 = go.Figure(go.Indicator(
        mode="gauge+number",
        value=ratios["ratio_gastos_fijos"]*100,
        title={"text":"Ratio Gastos Fijos / Ingresos (%)"},
        gauge={"axis":{"range":[0,100]}, "bar":{"color":"#444"}}
    ))
    fig_g2.update_layout(height=260, margin=dict(l=10,r=10,t=40,b=10))

    g2.plotly_chart(fig_g2, use_container_width=True)

    fig_g3 = go.Figure(go.Indicator(
        mode="gauge+number",
        value=ratios["fi_index"],
        title={"text":"FI Index (%)"},
        gauge={"axis":{"range":[0,150]}, "bar":{"color":"#444"}}
    ))
    fig_g3.update_layout(height=260, margin=dict(l=10,r=10,t=40,b=10))
    g3.plotly_chart(fig_g3, use_container_width=True)

    # Net worth line
    fig_nw = px.line(nw_df, x="Mes", y="Patrimonio_Neto", title="Evoluci√≥n de Patrimonio Neto (aprox)")
    fig_nw.update_layout(height=360, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_nw, use_container_width=True)

    st.caption("Asesor: Patrimonio mensual es aproximado porque tarjetas no tienen hist√≥rico y las inversiones usan valor actual como proxy por mes.")


# ----------------------------
# Tab 2 ‚Äî Cashflow + FCF
# ----------------------------
with tab2:
    with st.expander("Conceptos Clave"):
        st.write("**Flujo de Caja**: Es como ver el camino del agua. Muestra cu√°nto dinero entra y cu√°nto sale. Si sale m√°s de lo que entra, el tanque se vac√≠a.")
        st.write("**EBITDA Personal**: Es cu√°nto dinero generas con tu trabajo antes de pagar impuestos y gastos grandes. Es tu 'potencia' para generar dinero.")
    st.subheader("Flujo de caja, EBITDA personal y Free Cash Flow personal")

    k1, k2, k3, k4 = st.columns(4)
    k1.metric("Ingreso mensual promedio", money(dfm["Ingresos_Netos"].mean(), ass.currency_symbol))
    k2.metric("Gasto mensual promedio", money(dfm["Gastos_Totales"].mean(), ass.currency_symbol))
    k3.metric("Flujo neto mensual promedio", money(dfm["Flujo_Neto"].mean(), ass.currency_symbol))
    k4.metric("EBITDA personal promedio", money(dfm["EBITDA_Personal"].mean(), ass.currency_symbol))

    # Table
    show = dfm[["Mes","Ingresos_Netos","Gastos_Totales","Flujo_Neto","Tasa_Ahorro","EBITDA_Personal","FCF_Personal"]].copy()
    show["Tasa_Ahorro"] = (show["Tasa_Ahorro"]*100).round(1)
    st.dataframe(show, use_container_width=True, hide_index=True)

    # Bars by category (stacked) ‚Äî variable expenses by category
    gv["Periodo"] = get_period_series(gv["Fecha"], freq=freq_code)
    gv_cat = gv.groupby(["Periodo","Categor√≠a"])["Monto"].sum().reset_index()
    fig_stack = px.bar(gv_cat, x="Periodo", y="Monto", color="Categor√≠a", title="Gastos Variables por Categor√≠a (barras apiladas)")
    fig_stack.update_layout(height=380, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_stack, use_container_width=True)

    # Heatmap: expenses by day x category
    mov2 = mov.copy()
    mov2["Fecha"] = pd.to_datetime(mov2["Fecha"])
    mov2["Dia"] = mov2["Fecha"].dt.date
    mov2["Gasto_Pos"] = (-mov2["Monto"]).clip(lower=0)
    heat = mov2.groupby(["Dia","Categor√≠a"])["Gasto_Pos"].sum().reset_index()
    if not heat.empty:
        pivot = heat.pivot_table(index="Dia", columns="Categor√≠a", values="Gasto_Pos", aggfunc="sum").fillna(0.0)
        fig_heat = px.imshow(pivot.T, aspect="auto", title="Mapa de calor ‚Äî Gastos por d√≠a y categor√≠a")
        fig_heat.update_layout(height=420, margin=dict(l=10,r=10,t=40,b=10))
        st.plotly_chart(fig_heat, use_container_width=True)

    st.caption("Asesor: El Free Cash Flow personal usa CapEx = Educaci√≥n + Salud (puedes ajustar esa definici√≥n si quieres).")

    # Money velocity
    st.markdown("### 8) Money Velocity (cu√°n r√°pido gastas lo que ganas)")
    if mv_df.empty:
        st.info("No se pudo calcular money velocity (revisa ingresos por periodo).")
    else:
        mv_show = mv_df.copy()
        mv_show["Ingreso_Periodo"] = mv_show["Ingreso_Periodo"].map(lambda x: money(x, ass.currency_symbol))
        mv_show["Velocidad"] = mv_df["Velocidad"].round(2)
        mv_show["Dias_hasta_50pct"] = mv_df["Dias_hasta_50pct"].round(1)
        st.dataframe(mv_show[["Periodo","Ingreso_Periodo","Dias_hasta_50pct","Velocidad","Fecha_50pct"]], use_container_width=True, hide_index=True)
        fig_mv = px.line(mv_df, x="Periodo", y="Dias_hasta_50pct", title="D√≠as hasta gastar 50% del ingreso (por periodo)")
        fig_mv.update_layout(height=320, margin=dict(l=10,r=10,t=40,b=10))
        st.plotly_chart(fig_mv, use_container_width=True)

    # Opportunity cost
    st.markdown("### 7) Costo de oportunidad (gastos grandes)")
    if oc_tbl.empty:
        st.info("No hay gastos variables por encima del umbral configurado.")
    else:
        cols = ["Fecha","Categor√≠a","Subcategor√≠a","Monto","Valor_Futuro","Costo_Oportunidad"]
        tmp = oc_tbl.copy()
        tmp["Fecha"] = tmp["Fecha"].dt.date
        st.dataframe(tmp[cols].head(50), use_container_width=True, hide_index=True)
        fig_oc = px.bar(tmp.head(20), x="Monto", y="Descripci√≥n", orientation="h",
                        title=f"Top gastos grandes (>= {money(oc_threshold, ass.currency_symbol)}) ‚Äî referencia")
        fig_oc.update_layout(height=520, margin=dict(l=10,r=10,t=40,b=10))
        st.plotly_chart(fig_oc, use_container_width=True)


# ----------------------------
# Tab 3 ‚Äî Ratios + Net Worth Composition
# ----------------------------
with tab3:
    with st.expander("Conceptos Clave"):
        st.write("**Ratios**: Son como tus signos vitales. Te dicen si tu salud financiera est√° bien o mal.")
        st.write("**Patrimonio Neto**: Es lo que realmente tienes. Si vendieras todo lo que tienes y pagaras todas tus deudas, ¬øcu√°nto dinero te quedar√≠a en la mano?")
    st.subheader("Ratios financieros + composici√≥n patrimonial")

    r1, r2, r3, r4, r5 = st.columns(5)
    r1.metric("Ratio Deuda/Ingresos", f"{ratios['ratio_deuda_ingresos']*100:.1f}%")
    r1.caption(get_insight("Debt Ratio", ratios['ratio_deuda_ingresos']))
    
    r2.metric("Ratio Liquidez (meses)", f"{ratios['ratio_liquidez']:.1f}")
    r2.caption(get_insight("Liquidity", ratios['ratio_liquidez']))
    
    r3.metric("Tasa Ahorro Global", f"{ratios['tasa_ahorro_global']*100:.1f}%")
    r3.caption(get_insight("Savings Rate", ratios['tasa_ahorro_global']))
    
    r4.metric("Utilizaci√≥n cr√©dito", f"{ratios['util_credito']*100:.1f}%")
    r4.caption("üí° Tip: Mant√©n esto bajo (<30%) para mejorar tu score crediticio.")
    
    r5.metric("FI Index", f"{ratios['fi_index']:.1f}%")
    r5.caption("üí° Tip: 100% significa que eres financieramente libre.")

    # Recommendations for Ratios
    st.markdown("##### ü§ñ An√°lisis de Salud Financiera")
    recs_ratios = get_recommendations(ratios, dfm)
    # Filter only relevant ones for this tab (Savings, Liquidity)
    for icon, title, text in recs_ratios:
        if "Ahorro" in title or "Liquidez" in title or "Fondo" in title:
            st.info(f"{icon} **{title}**: {text}")

    # Composition pie (Refined for Productive vs Consumption)
    st.markdown("### 9) Composici√≥n Patrimonial (Productivo vs Consumo)")
    
    # Logic:
    # Productivo = Inversiones
    # Consumo/Improductivo = Bienes (Casa, Auto, etc.)
    # Liquidez = Caja
    
    val_prod = ratios["inversiones_valor"]
    val_cons = ass.bienes_value
    val_liq = ratios["activos_liquidos"]
    total_pat = val_prod + val_cons + val_liq
    
    ratio_prod = safe_div(val_prod, total_pat)
    
    pie_assets = pd.DataFrame({
        "Tipo": ["Patrimonio Productivo (Inversiones)", "Patrimonio de Consumo (Bienes)", "Liquidez (Caja)"],
        "Monto": [val_prod, val_cons, val_liq]
    })
    
    c_pie1, c_pie2 = st.columns([2, 1])
    with c_pie1:
        fig_pie = px.pie(pie_assets, names="Tipo", values="Monto", title="Distribuci√≥n de Activos", hole=0.3)
        fig_pie.update_traces(textposition='inside', textinfo='percent+label')
        st.plotly_chart(fig_pie, use_container_width=True)
    with c_pie2:
        st.metric("Ratio Productivo", f"{ratio_prod*100:.1f}%", help="Idealmente > 60%. Es el % de tu dinero que trabaja para ti.")
        st.caption("üí° Tip: Cuanto mayor sea este n√∫mero, menos dependes de tu trabajo.")
        if ratio_prod < 0.25:
            st.warning("Tu patrimonio productivo es bajo. Trata de invertir m√°s.")
        elif ratio_prod > 0.60:
            st.success("¬°Excelente estructura patrimonial!")


    # Net worth breakdown line
    fig_nw2 = px.line(
        nw_df.melt(id_vars="Mes", value_vars=["Activos_Caja","Activos_Inversiones","Pasivos_Deudas","Patrimonio_Neto"],
                   var_name="Serie", value_name="Monto"),
        x="Mes", y="Monto", color="Serie", title="Activos / Pasivos y Patrimonio (mensual aprox)"
    )
    fig_nw2.update_layout(height=380, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_nw2, use_container_width=True)

    # Break-even point stats
    st.subheader("Punto de equilibrio personal (Break-even)")
    # monthly fixed / monthly income
    fixed_avg = float(dfm["Gastos_Fijos"].mean())
    inc_avg = float(dfm["Ingresos_Netos"].mean())
    pct_comp = safe_div(fixed_avg, inc_avg)
    days_work = safe_div(fixed_avg, safe_div(inc_avg, 30.0))
    st.write(
        f"- % ingreso comprometido en gastos fijos: **{pct_comp*100:.1f}%**\n"
        f"- Ingreso m√≠nimo para cubrir fijos (prom): **{money(fixed_avg, ass.currency_symbol)}**\n"
        f"- D√≠as del mes trabajando ‚Äúsolo para obligaciones‚Äù (aprox): **{days_work:.1f} d√≠as**"
    )

    # Runway
    st.subheader("Runway financiero (pista de aterrizaje)")
    runway_display = runway_with_liq if ass.runway_include_investments else runway_normal
    st.write(
        f"- Burn rate normal (prom): **{money(burn_normal, ass.currency_symbol)}/mes**\n"
        f"- Burn rate supervivencia (esenciales): **{money(burn_survival, ass.currency_symbol)}/mes**\n"
        f"- Runway normal: **{runway_normal:.1f} meses**\n"
        f"- Runway supervivencia: **{runway_survival:.1f} meses**\n"
        f"- Runway con liquidaci√≥n inversiones (haircut {ass.invest_liquidation_haircut:.0%}): **{runway_with_liq:.1f} meses**"
    )

    # Risk exposure
    st.markdown("### 6) Exposici√≥n al riesgo (resumen)")
    # income single source risk: top category share
    inc_by_cat = ingresos.groupby("Categor√≠a")["Monto_Neto"].sum()
    top_share = safe_div(inc_by_cat.max(), inc_by_cat.sum())
    debt_payment_ratio = safe_div(dfm["Pagos_Deuda"].sum(), dfm["Ingresos_Netos"].sum())
    lifestyle_inflation = 0.0
    if len(dfm) >= 3:
        # slope comparison: expenses vs income
        x = np.arange(len(dfm))
        inc_slope = np.polyfit(x, dfm["Ingresos_Netos"].values, 1)[0]
        exp_slope = np.polyfit(x, dfm["Gastos_Totales"].values, 1)[0]
        lifestyle_inflation = safe_div(exp_slope, abs(inc_slope) + 1e-9)

    st.write(
        f"- Riesgo de ingreso √∫nico (share mayor fuente): **{top_share*100:.1f}%**\n"
        f"- Riesgo de deuda (pagos deuda / ingresos): **{debt_payment_ratio*100:.1f}%**\n"
        f"- Riesgo de liquidez (meses de cobertura): **{ratios['ratio_liquidez']:.1f}**\n"
        f"- Inflaci√≥n de estilo de vida (tendencia gastos / tendencia ingresos): **{lifestyle_inflation:.2f}** (heur√≠stico)"
    )
    
    # FI index categories
    st.markdown("### 10) FI Index (indicador de independencia financiera)")
    st.write(
        f"Ingreso pasivo mensual (prom): **{money(ratios['passive_monthly'], ass.currency_symbol)}**\n\n"
        f"FI Index = (Ingreso pasivo / Gastos mensuales) √ó 100 = **{ratios['fi_index']:.1f}%**"
    )


# ----------------------------
# Tab 4 ‚Äî Debt analysis & strategies
# ----------------------------
with tab4:
    with st.expander("Conceptos Clave"):
        st.write("**Estrategias de Deuda**: Hay dos formas principales de atacar al monstruo de la deuda:")
        st.write("1. **Avalancha**: Atacas primero a la deuda que te cobra m√°s intereses (la m√°s peligrosa). Es la m√°s r√°pida y barata matem√°ticamente.")
        st.write("2. **Bola de Nieve**: Atacas primero a la deuda m√°s peque√±a. Te da victorias r√°pidas y motivaci√≥n.")
    st.subheader("An√°lisis de deudas (incluye avalancha vs bola de nieve vs h√≠brido)")

    # Debt total + monthly interest paid
    pagos2 = data["Pagos_Deudas"].copy()
    pagos2["Periodo"] = get_period_series(pagos2["Fecha_Pago"], freq=freq_code)
    interest_m = pagos2.groupby("Periodo")["Monto_Intereses"].sum().reset_index()
    st.metric("Deuda total (deudas + tarjetas)", money(ratios["pasivos_totales"], ass.currency_symbol))

    fig_int = px.bar(interest_m, x="Periodo", y="Monto_Intereses", title="Costo financiero (intereses pagados)")
    fig_int.update_layout(height=330, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_int, use_container_width=True)

    # Recommendations for Debt
    st.markdown("##### ü§ñ Consejos sobre tu Deuda")
    recs_debt = get_recommendations(ratios, dfm)
    for icon, title, text in recs_debt:
        if "Deuda" in title or "Endeudamiento" in title:
            st.info(f"{icon} **{title}**: {text}")

    st.subheader("Comparaci√≥n de estrategias (con tus saldos actuales)")
    cA, cB, cC = st.columns(3)
    cA.metric("Avalancha ‚Äî inter√©s total", money(int_av, ass.currency_symbol))
    cA.caption("üí° Tip: Ahorras m√°s dinero con este m√©todo.")
    
    cB.metric("Bola de Nieve ‚Äî inter√©s total", money(int_sn, ass.currency_symbol))
    cB.caption("üí° Tip: Ganas motivaci√≥n r√°pida eliminando deudas chicas.")
    
    cC.metric("H√≠brido ‚Äî inter√©s total", money(int_hy, ass.currency_symbol))
    cC.caption("üí° Tip: Balance entre matem√°tica y psicolog√≠a.")

    cA2, cB2, cC2 = st.columns(3)
    cA2.metric("Avalancha ‚Äî meses a pagar", f"{months_av}")
    cB2.metric("Bola de nieve ‚Äî meses a pagar", f"{months_sn}")
    cC2.metric("H√≠brido ‚Äî meses a pagar", f"{months_hy}")

    # Plot payoff balances over time for each strategy (sum of balances)
    def sum_balances(sch):
        b = sch.loc[sch["type"] == "balance"].copy()
        if "balance_end" not in b.columns:
            return pd.DataFrame()
        b = b.groupby("month")["balance_end"].sum().reset_index()
        return b

    bal_av = sum_balances(sch_av).rename(columns={"balance_end":"Avalancha"})
    bal_sn = sum_balances(sch_sn).rename(columns={"balance_end":"Nieve"})
    bal_hy = sum_balances(sch_hy).rename(columns={"balance_end":"Hibrido"})

    merged = bal_av.merge(bal_sn, on="month", how="outer").merge(bal_hy, on="month", how="outer").fillna(method="ffill").fillna(0.0)
    fig_pay = px.line(merged.melt(id_vars="month", var_name="Estrategia", value_name="Saldo"),
                      x="month", y="Saldo", color="Estrategia", title="Timeline de deuda (saldo total) ‚Äî Gantt/curva de pago")
    fig_pay.update_layout(height=380, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_pay, use_container_width=True)

    st.caption("Asesor: El simulador asume pago m√≠nimo fijo + tu 'pago extra mensual'. Si quieres, lo expandimos a pagos variables por mes.")





# ----------------------------
# Tab 6 ‚Äî Projections & sensitivity
# ----------------------------
with tab6:
    with st.expander("Conceptos Clave"):
        st.write("**Proyecciones**: Es como una bola de cristal (basada en matem√°ticas) para ver tu futuro.")
        st.write("**Runway (Pista de aterrizaje)**: Si hoy dejaras de trabajar, ¬øcu√°ntos meses podr√≠as vivir con tus ahorros antes de quedarte en cero?")
    st.subheader("Proyecciones, metas y escenarios")

    # Projection Years Input
    proj_years = st.number_input("A√±os a proyectar", min_value=1, max_value=50, value=5, step=1, help="Define el horizonte de tiempo para la simulaci√≥n.")

    # Forecast chart
    # Recalculate forecast with user input years
    base_sav = float(dfm["Flujo_Neto"].tail(3).mean()) if len(dfm) else 0.0
    forecast_df = forecast_net_worth(nw_df, base_sav, years=proj_years, a=ass)
    
    fig_fc = px.line(forecast_df, x="Mes_Futuro", y=["Base","Optimista","Pesimista"], title=f"Proyecci√≥n Patrimonio ({proj_years} a√±os)")
    fig_fc.update_layout(height=400, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_fc, use_container_width=True)
    st.caption("üí° Tip: El escenario 'Base' asume que mantienes tu ahorro actual. Peque√±os cambios hoy hacen gran diferencia en 5 a√±os.")
    
    # Savings projection 6/12
    st.markdown("### Proyecci√≥n de ahorro (6 / 12 meses)")
    avg_flow = float(dfm["Flujo_Neto"].tail(3).mean()) if len(dfm) else 0.0
    proj6 = avg_flow * 6
    proj12 = avg_flow * 12
    c1, c2 = st.columns(2)
    c1.metric("Ahorro proyectado 6 meses (prom √∫ltimos 3)", money(proj6, ass.currency_symbol))
    c2.metric("Ahorro proyectado 12 meses (prom √∫ltimos 3)", money(proj12, ass.currency_symbol))

    # Goals time-to-target
    st.markdown("### Tiempo para metas financieras")
    metas = data["Metas_Financieras"].copy()
    metas["Restante"] = (metas["Monto_Objetivo"] - metas["Monto_Acumulado"]).clip(lower=0)
    metas["Meses_estimados"] = metas.apply(lambda r: math.ceil(safe_div(r["Restante"], r["Aporte_Mensual_Planeado"])) if r["Aporte_Mensual_Planeado"]>0 else np.nan, axis=1)
    st.dataframe(metas[["Nombre_Meta","Categor√≠a","Monto_Objetivo","Monto_Acumulado","Restante","Aporte_Mensual_Planeado","Meses_estimados","Prioridad","Estado"]],
                 use_container_width=True, hide_index=True)

    fig_goals = px.line(
        metas.assign(Porcentaje=metas["Porcentaje_Completado"]*100),
        x="Nombre_Meta", y="Porcentaje", markers=True, title="Progreso de metas (%)"
    )
    fig_goals.update_layout(height=320, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_goals, use_container_width=True)

    # Forecast net worth scenarios (1,5,10,20 years) ‚Äî show 5-year curve
    st.markdown("### Forecast de patrimonio neto (3 escenarios) ‚Äî 5 a√±os")
    fig_fc = px.line(forecast_df.melt(id_vars="Mes_Futuro", var_name="Escenario", value_name="Patrimonio"),
                     x="Mes_Futuro", y="Patrimonio", color="Escenario", title="Patrimonio neto proyectado (mensual)")
    fig_fc.update_layout(height=380, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_fc, use_container_width=True)

    # Retirement projection (rough)
    st.markdown("### Jubilaci√≥n ‚Äî referencia r√°pida (muy pr√°ctico)")
    exp_month = st.number_input("Gasto mensual objetivo en jubilaci√≥n (referencia)", min_value=0.0, value=float(ratios["gasto_mensual_prom"]), step=100.0)
    needed_capital = safe_div(exp_month*12, ass.swr)  # capital needed for annual spending at SWR
    st.write(
        f"- Capital estimado necesario (SWR {ass.swr:.0%}): **{money(needed_capital, ass.currency_symbol)}**\n"
        f"- Patrimonio actual: **{money(ratios['patrimonio_neto_actual'], ass.currency_symbol)}**\n"
        f"- Brecha estimada: **{money(max(0.0, needed_capital - ratios['patrimonio_neto_actual']), ass.currency_symbol)}**"
    )

    # Sensitivity analysis
    st.markdown("### 12) An√°lisis de sensibilidad (what-if)")
    s1, s2, s3 = st.columns(3)
    job_loss_months = s1.slider("P√©rdida de empleo (meses)", 0, 12, 6, 1)
    emergency_cost = s2.number_input("Emergencia m√©dica (monto)", min_value=0.0, value=10000.0, step=500.0)
    rate_shock = s3.slider("Shock tasa inter√©s mensual (tarjetas) +", 0.0, 0.05, 0.01, 0.005)

    liquid = ratios["activos_liquidos"]
    runway_after_jobloss = safe_div(liquid, burn_survival)  # survival runway (months)
    liquid_after_emergency = max(0.0, liquid - emergency_cost)
    runway_after_emergency = safe_div(liquid_after_emergency, burn_survival)

    # debt interest shock approximation
    tarjetas = data["Tarjetas_Credito"].copy()
    shock_cost = float((tarjetas["Saldo_Actual"] * rate_shock).sum()) if not tarjetas.empty else 0.0

    st.write(
        f"- Runway supervivencia actual: **{runway_survival:.1f} meses**\n"
        f"- Si pierdes el trabajo {job_loss_months} meses: recomendado tener runway >= {job_loss_months}. Tu runway: **{runway_survival:.1f}**\n"
        f"- Si ocurre emergencia de {money(emergency_cost, ass.currency_symbol)}: runway baja a **{runway_after_emergency:.1f} meses**\n"
        f"- Shock de tasa tarjetas +{rate_shock*100:.1f}% mensual ‚âà costo extra mensual: **{money(shock_cost, ass.currency_symbol)}**"
    )

    # Goal acceleration
    st.markdown("### 13) Aceleraci√≥n de objetivos (10% + ahorro / - gastos)")
    delta = 0.10
    cur_save = max(0.0, avg_flow)
    save_plus = cur_save * (1 + delta)
    spend_minus_effect = cur_save + (ratios["gasto_mensual_prom"] * delta)  # if reduce spend 10%, savings increase
    both = save_plus + (ratios["gasto_mensual_prom"] * delta)

    # Pick one meta to showcase
    meta_names = metas["Nombre_Meta"].tolist() if len(metas) else ["(sin metas)"]
    chosen = st.selectbox("Meta a evaluar", meta_names, index=0)
    if len(metas) and chosen in metas["Nombre_Meta"].values:
        r = metas.loc[metas["Nombre_Meta"] == chosen].iloc[0]
        remaining = float(r["Restante"])

        def months_to_goal(monthly_add):
            return math.ceil(safe_div(remaining, monthly_add)) if monthly_add > 0 else np.inf

        m0 = months_to_goal(max(1e-9, cur_save))
        m1 = months_to_goal(max(1e-9, save_plus))
        m2 = months_to_goal(max(1e-9, spend_minus_effect))
        m3 = months_to_goal(max(1e-9, both))

        st.write(
            f"- Tiempo actual: **{m0} meses**\n"
            f"- Si aumentas ahorro 10%: **{m1} meses** (Œî {(m0-m1)} meses)\n"
            f"- Si reduces gastos 10%: **{m2} meses** (Œî {(m0-m2)} meses)\n"
            f"- Si haces ambos: **{m3} meses** (Œî {(m0-m3)} meses)"
        )

    # Tax efficiency quick view
    st.markdown("### 14) Eficiencia fiscal (b√°sico con tu data)")
    ing = data["Ingresos"].copy()
    tax_paid = float(ing["Impuestos_Retenciones"].sum()) if "Impuestos_Retenciones" in ing.columns else 0.0
    gross = float(ing["Monto_Bruto"].sum()) if "Monto_Bruto" in ing.columns else 0.0
    eff_tax = safe_div(tax_paid, gross)
    st.write(
        f"- Impuestos/retenciones registradas: **{money(tax_paid, ass.currency_symbol)}**\n"
        f"- Ingreso bruto total: **{money(gross, ass.currency_symbol)}**\n"
        f"- Tasa efectiva aproximada: **{eff_tax*100:.1f}%**"
    )
    
    # Simple Bracket Estimator (Generic)
    st.caption("Estimaci√≥n de tramo (referencial):")
    if eff_tax < 0.08:
        st.info("Tramo Bajo: Parece que pagas pocos impuestos. ¬°Aprovecha para ahorrar m√°s!")
    elif eff_tax < 0.20:
        st.warning("Tramo Medio: Est√°s en el promedio. Revisa si puedes deducir gastos de educaci√≥n o salud.")
    else:
        st.error("Tramo Alto: Est√°s pagando una tasa alta. Considera estrategias de inversi√≥n con beneficios fiscales.")
        
    with st.expander("Estrategias de Optimizaci√≥n Fiscal"):
        st.markdown("""
        1.  **Deducciones**: Aseg√∫rate de pedir factura en gastos deducibles (restaurantes, hoteles, servicios profesionales) si tu pa√≠s lo permite.
        2.  **Aportes Voluntarios**: En muchos pa√≠ses, aportar extra a tu fondo de pensiones reduce tu base imponible.
        3.  **Timing**: Si puedes diferir el cobro de un bono para enero, podr√≠as postergar el pago de impuestos un a√±o.
        """)

# ----------------------------
# Tab 7 ‚Äî Glosario Financiero (Wiki)
# ----------------------------
with tab7:
    st.header("Glosario Financiero Detallado")
    st.markdown("Aqu√≠ encontrar√°s explicaciones detalladas de cada t√©rmino utilizado en la aplicaci√≥n, junto con ejemplos pr√°cticos.")

    glossary = {
        "Flujo de Caja (Cashflow)": {
            "Definici√≥n": "Es el registro de todo el dinero que entra (ingresos) y sale (gastos) de tu bolsillo en un periodo de tiempo.",
            "Ejemplo": "Si ganas 1000 y gastas 800, tu flujo de caja neto es +200. Si gastas 1200, es -200.",
            "Importancia": "Es la base de las finanzas. Sin flujo positivo, no hay ahorro ni inversi√≥n."
        },
        "EBITDA Personal": {
            "Definici√≥n": "Significa 'Earnings Before Interest, Taxes, Depreciation, and Amortization' (Beneficios antes de intereses, impuestos, etc.). En finanzas personales, es tu capacidad de generar dinero con tu trabajo antes de pagar deudas o impuestos.",
            "Ejemplo": "Tu salario bruto es 5000. Tus gastos b√°sicos para vivir (comida, transporte al trabajo) son 2000. Tu EBITDA Personal es 3000.",
            "Importancia": "Mide tu 'potencia' productiva bruta."
        },
        "Patrimonio Neto": {
            "Definici√≥n": "Es el valor real de tu riqueza. Se calcula restando todo lo que debes (Pasivos) de todo lo que tienes (Activos).",
            "Ejemplo": "Tienes una casa de 100,000 y ahorros por 10,000 (Activos = 110,000). Debes 80,000 de hipoteca (Pasivos). Tu Patrimonio Neto es 30,000.",
            "Importancia": "Es el indicador n√∫mero uno de riqueza real. Puedes tener muchos lujos (activos) pero si debes todo, tu patrimonio es cero."
        },
        "Runway (Pista de Aterrizaje)": {
            "Definici√≥n": "El tiempo (en meses) que podr√≠as sobrevivir sin ingresos, viviendo solo de tus ahorros actuales.",
            "Ejemplo": "Tienes 5000 ahorrados. Gastas 1000 al mes. Tu runway es de 5 meses.",
            "Importancia": "Es tu red de seguridad ante despidos o crisis."
        },
        "M√©todo Avalancha": {
            "Definici√≥n": "Estrategia para pagar deudas donde priorizas la deuda con la TASA DE INTER√âS m√°s alta.",
            "Ejemplo": "Debes 1000 al 20% y 5000 al 5%. Pagas primero la de 1000.",
            "Importancia": "Matem√°ticamente es la forma m√°s barata y r√°pida de salir de deudas."
        },
        "M√©todo Bola de Nieve": {
            "Definici√≥n": "Estrategia donde priorizas la deuda con el SALDO m√°s peque√±o, sin importar el inter√©s.",
            "Ejemplo": "Debes 1000 al 5% y 5000 al 20%. Pagas primero la de 1000 para eliminarla r√°pido.",
            "Importancia": "Psicol√≥gicamente muy efectiva porque ves progresos r√°pidos (cierras deudas enteras)."
        },
        "Inter√©s Compuesto": {
            "Definici√≥n": "Es ganar intereses sobre los intereses que ya ganaste. Hace que tu dinero crezca exponencialmente.",
            "Ejemplo": "Inviertes 100 al 10%. Ganas 10. Ahora tienes 110. El siguiente a√±o ganas el 10% de 110 (11), no de 100.",
            "Importancia": "Es la fuerza m√°s poderosa para construir riqueza a largo plazo."
        }
    }

    for term, details in glossary.items():
        with st.expander(f"üìò {term}"):
            st.markdown(f"**Definici√≥n:** {details['Definici√≥n']}")
            st.markdown(f"**Ejemplo:** *{details['Ejemplo']}*")
            st.info(f"**¬øPor qu√© importa?** {details['Importancia']}")



# Inject Recommendations into Dashboard
with tab0:
    st.divider()
    st.subheader("ü§ñ Recomendaciones Personalizadas (IA Asistente)")
    recs = get_recommendations(ratios, dfm)
    for icon, title, text in recs:
        st.info(f"{icon} **{title}**: {text}")