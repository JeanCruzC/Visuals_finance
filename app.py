# -*- coding: utf-8 -*-
"""App.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zQZ_FKlvf8FmIOJ342ABjBV-fZJgnPXW
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from dataclasses import dataclass
from datetime import datetime, date
import math

st.set_page_config(page_title="Finanzas Personales ‚Äî Dashboard", layout="wide")


# ----------------------------
# Helpers
# ----------------------------
def money(x, symbol="S/ "):
    if x is None or (isinstance(x, float) and np.isnan(x)):
        return f"{symbol}0.00"
    return f"{symbol}{x:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")

def safe_div(a, b):
    return float(a) / float(b) if b not in [0, 0.0, None] and not pd.isna(b) else 0.0

def month_str(dt_series):
    return pd.to_datetime(dt_series).dt.to_period("M").astype(str)

def ensure_datetime(df, col):
    if col in df.columns:
        df[col] = pd.to_datetime(df[col], errors="coerce")
    return df

def clamp(x, lo, hi):
    return max(lo, min(hi, x))

def hhi(shares):
    """Herfindahl-Hirschman Index for concentration."""
    s = np.array(shares, dtype=float)
    s = s[s > 0]
    if s.sum() == 0:
        return 1.0
    p = s / s.sum()
    return float(np.sum(p**2))


# ----------------------------
# Data loading
# ----------------------------
REQUIRED_SHEETS = [
    "Datos_Maestros",
    "Ingresos",
    "Gastos_Fijos",
    "Gastos_Variables",
    "Deudas_Prestamos",
    "Pagos_Deudas",
    "Inversiones",
    "Cuentas_Bancarias",
    "Tarjetas_Credito",
    "Presupuesto_Mensual",
    "Metas_Financieras",
    "Movimientos_Consolidados",
]

@st.cache_data(show_spinner=False)
def load_excel(file) -> dict:
    xls = pd.ExcelFile(file)
    missing = [s for s in REQUIRED_SHEETS if s not in xls.sheet_names]
    if missing:
        raise ValueError(f"Faltan hojas en el Excel: {missing}")

    data = {}
    for s in REQUIRED_SHEETS:
        data[s] = pd.read_excel(xls, sheet_name=s)

    # Parse datetimes
    data["Ingresos"] = ensure_datetime(data["Ingresos"], "Fecha")
    data["Gastos_Fijos"] = ensure_datetime(data["Gastos_Fijos"], "Fecha_Cargo")
    data["Gastos_Variables"] = ensure_datetime(data["Gastos_Variables"], "Fecha")
    data["Pagos_Deudas"] = ensure_datetime(data["Pagos_Deudas"], "Fecha_Pago")
    data["Inversiones"] = ensure_datetime(data["Inversiones"], "Fecha_Inversi√≥n")
    data["Movimientos_Consolidados"] = ensure_datetime(data["Movimientos_Consolidados"], "Fecha")

    return data


# ----------------------------
# KPI computation core
# ----------------------------
@dataclass
class Assumptions:
    currency_symbol: str = "S/ "
    include_investments_in_cashflow: bool = False
    include_debt_payments_in_expenses: bool = True
    runway_include_debts: bool = True
    runway_include_investments: bool = False
    invest_liquidation_haircut: float = 0.7

    expected_return_annual: float = 0.08
    inflation_annual: float = 0.03
    swr: float = 0.04  # safe withdraw rate

    extra_debt_payment_monthly: float = 0.0

    # user entered "bienes" (assets non-liquid)
    bienes_value: float = 0.0

    # happiness / value (optional)
    happiness_scale: dict = None  # category -> 1..10 value
    value_scale: dict = None      # category -> 1..10 long-term value


def build_monthly_table(data: dict, a: Assumptions):
    ingresos = data["Ingresos"].copy()
    gf = data["Gastos_Fijos"].copy()
    gv = data["Gastos_Variables"].copy()
    pagos = data["Pagos_Deudas"].copy()
    inv = data["Inversiones"].copy()
    mov = data["Movimientos_Consolidados"].copy()

    ingresos["Mes"] = month_str(ingresos["Fecha"])
    gf["Mes"] = month_str(gf["Fecha_Cargo"])
    gv["Mes"] = month_str(gv["Fecha"])
    pagos["Mes"] = month_str(pagos["Fecha_Pago"])
    inv["Mes"] = month_str(inv["Fecha_Inversi√≥n"])
    mov["Mes"] = month_str(mov["Fecha"])

    # Monthly totals
    income_m = ingresos.groupby("Mes")["Monto_Neto"].sum().rename("Ingresos_Netos")
    fixed_m  = gf.groupby("Mes")["Monto"].sum().rename("Gastos_Fijos")
    var_m    = gv.groupby("Mes")["Monto"].sum().rename("Gastos_Variables")
    debt_m   = pagos.groupby("Mes")["Monto_Total_Pagado"].sum().rename("Pagos_Deuda")
    inv_m    = inv.groupby("Mes")["Monto_Invertido"].sum().rename("Inversiones_Outflow")

    # Ensure index union
    idx = pd.Index(sorted(set(income_m.index) | set(fixed_m.index) | set(var_m.index) | set(debt_m.index) | set(inv_m.index)))
    dfm = pd.DataFrame(index=idx)
    dfm["Ingresos_Netos"] = income_m.reindex(idx).fillna(0.0)
    dfm["Gastos_Fijos"]   = fixed_m.reindex(idx).fillna(0.0)
    dfm["Gastos_Variables"]= var_m.reindex(idx).fillna(0.0)
    dfm["Pagos_Deuda"]    = debt_m.reindex(idx).fillna(0.0)
    dfm["Inversiones_Outflow"]= inv_m.reindex(idx).fillna(0.0)

    # Expenses definition
    dfm["Gastos_Totales"] = dfm["Gastos_Fijos"] + dfm["Gastos_Variables"]
    if a.include_debt_payments_in_expenses:
        dfm["Gastos_Totales"] += dfm["Pagos_Deuda"]
    if a.include_investments_in_cashflow:
        dfm["Gastos_Totales"] += dfm["Inversiones_Outflow"]

    dfm["Flujo_Neto"] = dfm["Ingresos_Netos"] - dfm["Gastos_Totales"]
    dfm["Tasa_Ahorro"] = dfm.apply(lambda r: safe_div(r["Flujo_Neto"], r["Ingresos_Netos"]), axis=1)

    # EBITDA Personal (adaptado)
    # Ingresos operativos = salario + recurrentes
    ingresos_oper = ingresos.loc[
        (ingresos["Categor√≠a"].astype(str).str.lower().str.contains("salario")) |
        (ingresos["Es_Recurrente"].astype(str).str.lower() == "s√≠")
    ].copy()
    ingresos_oper_m = ingresos_oper.groupby("Mes")["Monto_Neto"].sum().rename("Ingresos_Operativos")

    # Gastos operativos esenciales = fijos esenciales + variables necesarias
    gf_ess = gf.loc[gf.get("Es_Esencial", "").astype(str).str.lower() == "s√≠"].copy()
    gv_ess = gv.loc[gv.get("Es_Necesario", "").astype(str).str.lower() == "s√≠"].copy()
    opex_m = (gf_ess.groupby("Mes")["Monto"].sum() + gv_ess.groupby("Mes")["Monto"].sum()).rename("Opex_Esencial")

    dfm["Ingresos_Operativos"] = ingresos_oper_m.reindex(idx).fillna(0.0)
    dfm["Opex_Esencial"] = opex_m.reindex(idx).fillna(0.0)
    dfm["EBITDA_Personal"] = dfm["Ingresos_Operativos"] - dfm["Opex_Esencial"]

    # Personal Free Cash Flow: net income - essential opex - capex personal
    # CapEx personal: Educaci√≥n + Salud (variables) + (opcional) "Hogar/Mascota" en Otros
    capex = gv.loc[gv["Categor√≠a"].isin(["Educaci√≥n","Salud"])].copy()
    capex_m = capex.groupby("Mes")["Monto"].sum().rename("CapEx_Personal")
    dfm["CapEx_Personal"] = capex_m.reindex(idx).fillna(0.0)
    dfm["FCF_Personal"] = dfm["Ingresos_Netos"] - dfm["Opex_Esencial"] - dfm["CapEx_Personal"]

    # Budget adherence (planned vs actual): use Presupuesto_Mensual sheet
    pres = data["Presupuesto_Mensual"].copy()
    pres["Mes"] = pres["Mes_A√±o"].astype(str)
    planned_m = pres.groupby("Mes")["Presupuesto_Planeado"].sum().rename("Presupuesto_Planeado_Total")
    actual_m  = pres.groupby("Mes")["Gasto_Real"].sum().rename("Presupuesto_Gasto_Real_Total")
    dfm["Presupuesto_Planeado_Total"] = planned_m.reindex(idx).fillna(0.0)
    dfm["Presupuesto_Gasto_Real_Total"] = actual_m.reindex(idx).fillna(0.0)
    dfm["Budget_Adherence"] = dfm.apply(lambda r: 1 - safe_div(abs(r["Presupuesto_Gasto_Real_Total"]-r["Presupuesto_Planeado_Total"]), r["Presupuesto_Planeado_Total"]), axis=1)
    dfm["Budget_Adherence"] = dfm["Budget_Adherence"].clip(lower=0, upper=1)

    return dfm.reset_index().rename(columns={"index":"Mes"}), mov, ingresos, gf, gv, pagos, inv


def compute_ratios_and_balance(data: dict, dfm: pd.DataFrame, a: Assumptions):
    dm = data["Datos_Maestros"].iloc[0].to_dict()
    cuentas = data["Cuentas_Bancarias"].copy()
    tarjetas = data["Tarjetas_Credito"].copy()
    deudas = data["Deudas_Prestamos"].copy()
    inv = data["Inversiones"].copy()

    # Liquidity / assets
    activos_liquidos = float(cuentas["Saldo_Actual"].sum())
    inversiones_valor = float(inv["Valor_Actual"].sum()) if "Valor_Actual" in inv.columns else 0.0
    activos_totales = activos_liquidos + inversiones_valor + float(a.bienes_value)

    # Liabilities
    pasivos_deudas = float(deudas["Saldo_Actual"].sum()) if "Saldo_Actual" in deudas.columns else 0.0
    pasivos_tarjetas = float(tarjetas["Saldo_Actual"].sum()) if "Saldo_Actual" in tarjetas.columns else 0.0
    pasivos_totales = pasivos_deudas + pasivos_tarjetas

    patrimonio_neto_actual = activos_totales - pasivos_totales

    # Annualized income (net)
    total_income = float(dfm["Ingresos_Netos"].sum())
    months = max(1, dfm["Mes"].nunique())
    ingreso_mensual_prom = total_income / months
    ingreso_anual_estimado = ingreso_mensual_prom * 12

    # Average monthly expenses
    gasto_mensual_prom = float(dfm["Gastos_Totales"].mean()) if len(dfm) else 0.0

    # Ratios
    ratio_deuda_ingresos = safe_div(pasivos_totales, ingreso_anual_estimado)
    ratio_liquidez = safe_div(activos_liquidos, gasto_mensual_prom)
    tasa_ahorro_global = safe_div(dfm["Flujo_Neto"].sum(), dfm["Ingresos_Netos"].sum())
    ratio_gastos_fijos = safe_div(dfm["Gastos_Fijos"].sum(), dfm["Ingresos_Netos"].sum())

    limite_total = float(tarjetas["L√≠mite_Cr√©dito"].sum()) if "L√≠mite_Cr√©dito" in tarjetas.columns else 0.0
    util_credito = safe_div(pasivos_tarjetas, limite_total)

    # Passive income & FI Index
    ing = data["Ingresos"].copy()
    passive = ing.loc[ing["Categor√≠a"].astype(str).str.lower().isin(["inversiones","rentas"])].copy()
    passive_monthly = float(passive["Monto_Neto"].sum()) / months if months else 0.0
    fi_index = safe_div(passive_monthly, gasto_mensual_prom) * 100

    # Emergency fund progress
    fondo_obj = float(dm.get("Fondo_Emergencia_Objetivo", 0.0))
    emergencia_pct = safe_div(activos_liquidos, fondo_obj)

    return {
        "activos_liquidos": activos_liquidos,
        "inversiones_valor": inversiones_valor,
        "activos_totales": activos_totales,
        "pasivos_deudas": pasivos_deudas,
        "pasivos_tarjetas": pasivos_tarjetas,
        "pasivos_totales": pasivos_totales,
        "patrimonio_neto_actual": patrimonio_neto_actual,
        "ratio_deuda_ingresos": ratio_deuda_ingresos,
        "ratio_liquidez": ratio_liquidez,
        "tasa_ahorro_global": tasa_ahorro_global,
        "ratio_gastos_fijos": ratio_gastos_fijos,
        "util_credito": util_credito,
        "ingreso_anual_estimado": ingreso_anual_estimado,
        "gasto_mensual_prom": gasto_mensual_prom,
        "passive_monthly": passive_monthly,
        "fi_index": fi_index,
        "fondo_obj": fondo_obj,
        "emergencia_pct": emergencia_pct,
    }


# ----------------------------
# Debt strategy simulation
# ----------------------------
def build_debt_universe(data: dict):
    """Unify Deudas_Prestamos + Tarjetas_Credito as debts."""
    deudas = data["Deudas_Prestamos"].copy()
    tarjetas = data["Tarjetas_Credito"].copy()

    debts = []

    # Loans
    for _, r in deudas.iterrows():
        debts.append({
            "id": str(r["ID_Deuda"]),
            "name": f"{r.get('Tipo','Deuda')} ‚Äî {r.get('Acreedor','')}".strip(),
            "balance": float(r.get("Saldo_Actual", 0.0)),
            "rate_monthly": float(r.get("Tasa_Inter√©s_Anual", 0.0)) / 12.0,
            "min_payment": float(r.get("Cuota_Mensual", 0.0)),
            "kind": "loan"
        })

    # Credit cards
    for _, r in tarjetas.iterrows():
        debts.append({
            "id": str(r["ID_Tarjeta"]),
            "name": f"Tarjeta {r.get('Banco_Emisor','')} ‚Ä¢{r.get('√öltimos_4_D√≠gitos','')}".strip(),
            "balance": float(r.get("Saldo_Actual", 0.0)),
            "rate_monthly": float(r.get("Tasa_Inter√©s_Mensual", 0.0)),
            "min_payment": float(r.get("Pago_M√≠nimo", 0.0)),
            "kind": "card"
        })

    debts = [d for d in debts if d["balance"] > 0]
    return debts


def simulate_payoff(debts, extra_payment=0.0, strategy="avalanche", max_months=600):
    """
    strategies:
      - avalanche: extra to highest rate
      - snowball: extra to smallest balance
      - hybrid: weighted (0.6 interest, 0.4 balance)
    Returns schedule df + totals
    """
    debts = [d.copy() for d in debts]
    month = 0
    schedule = []
    total_interest = 0.0

    while month < max_months and any(d["balance"] > 0.01 for d in debts):
        month += 1

        # accrue interest
        for d in debts:
            if d["balance"] <= 0:
                continue
            interest = d["balance"] * d["rate_monthly"]
            total_interest += interest
            d["balance"] += interest

        # pay minimums first
        cash = extra_payment
        for d in debts:
            if d["balance"] <= 0:
                continue
            pay = min(d["min_payment"], d["balance"])
            d["balance"] -= pay
            schedule.append({"month": month, "debt_id": d["id"], "debt_name": d["name"], "payment": pay, "type": "min"})
        # choose target for extra
        alive = [d for d in debts if d["balance"] > 0.01]
        if alive and cash > 0:
            if strategy == "avalanche":
                target = max(alive, key=lambda x: x["rate_monthly"])
            elif strategy == "snowball":
                target = min(alive, key=lambda x: x["balance"])
            else:  # hybrid
                # normalize
                rates = np.array([x["rate_monthly"] for x in alive], float)
                bals  = np.array([x["balance"] for x in alive], float)
                r_norm = (rates - rates.min()) / (rates.max() - rates.min() + 1e-9)
                b_norm = (bals - bals.min()) / (bals.max() - bals.min() + 1e-9)
                score = 0.6 * r_norm + 0.4 * (1 - b_norm)  # prefer high rate + smaller balance a bit
                target = alive[int(np.argmax(score))]

            pay = min(cash, target["balance"])
            target["balance"] -= pay
            schedule.append({"month": month, "debt_id": target["id"], "debt_name": target["name"], "payment": pay, "type": "extra"})

        # snapshot balances end of month
        for d in debts:
            schedule.append({"month": month, "debt_id": d["id"], "debt_name": d["name"], "payment": 0.0, "type": "balance", "balance_end": max(0.0, d["balance"])})

    sch = pd.DataFrame(schedule)
    payoff_months = month
    return sch, total_interest, payoff_months


# ----------------------------
# Scores (0-1000) and advanced analytics
# ----------------------------
def compute_health_score(dfm, ratios, data: dict):
    """
    0-1000:
    - Savings rate (20%)
    - Income diversification (15%)
    - Debt burden (20%)
    - Emergency fund (15%)
    - Net worth growth (15%)
    - Planning / budget adherence (10%)
    - Financial education proxy (5%)
    """
    # Savings
    savings = clamp((ratios["tasa_ahorro_global"] + 0.2) / 0.4, 0, 1)  # -20%..+20% => 0..1
    # Diversification: 1 - HHI by income categories
    ing = data["Ingresos"].copy()
    shares = ing.groupby("Categor√≠a")["Monto_Neto"].sum().values
    div = clamp(1 - hhi(shares), 0, 1)
    # Debt burden: debt payments / income
    debt_burden = safe_div(dfm["Pagos_Deuda"].sum(), dfm["Ingresos_Netos"].sum()) if "Pagos_Deuda" in dfm else 0.0
    debt_score = clamp(1 - debt_burden / 0.35, 0, 1)  # >35% penaliza fuerte
    # Emergency coverage in months (liquid / avg monthly expenses)
    emer = clamp(ratios["ratio_liquidez"] / 6.0, 0, 1)  # 6 meses ideal
    # Net worth trend: sign of flujo neto rolling
    trend = 0.5
    if len(dfm) >= 3:
        x = dfm["Flujo_Neto"].rolling(3).mean().iloc[-1]
        trend = clamp((x / max(1, dfm["Ingresos_Netos"].mean())) * 5 + 0.5, 0, 1)  # heur√≠stico
    # Planning: budget adherence
    plan = float(dfm["Budget_Adherence"].mean()) if "Budget_Adherence" in dfm else 0.5
    # Education proxy: % spend on educaci√≥n up to 10% => full score (heur√≠stico)
    gv = data["Gastos_Variables"].copy()
    edu = gv.loc[gv["Categor√≠a"] == "Educaci√≥n", "Monto"].sum()
    total_spend = (dfm["Gastos_Fijos"].sum() + dfm["Gastos_Variables"].sum() + dfm["Pagos_Deuda"].sum())
    edu_ratio = safe_div(edu, total_spend)
    edu_score = clamp(edu_ratio / 0.10, 0, 1)

    weights = {"savings":0.20,"div":0.15,"debt":0.20,"emer":0.15,"trend":0.15,"plan":0.10,"edu":0.05}
    total = (
        savings*weights["savings"] + div*weights["div"] + debt_score*weights["debt"] +
        emer*weights["emer"] + trend*weights["trend"] + plan*weights["plan"] + edu_score*weights["edu"]
    )
    return int(round(total * 1000))


def compute_runway(ratios, dfm, a: Assumptions):
    liquid = ratios["activos_liquidos"]
    burn_normal = ratios["gasto_mensual_prom"]
    # survival burn = essential opex
    burn_survival = float(dfm["Opex_Esencial"].mean()) if "Opex_Esencial" in dfm and len(dfm) else burn_normal

    runway_normal = safe_div(liquid, burn_normal)
    runway_survival = safe_div(liquid, burn_survival)

    # with liquidation of investments (haircut)
    invest_liq = ratios["inversiones_valor"] * a.invest_liquidation_haircut
    runway_with_liq = safe_div(liquid + invest_liq, burn_normal)

    return runway_normal, runway_survival, runway_with_liq, burn_normal, burn_survival


def compute_money_velocity(mov: pd.DataFrame, ingresos: pd.DataFrame):
    """
    Money Velocity:
    velocity = ingresos_mensuales / d√≠as hasta gastar 50% del ingreso
    """
    mov = mov.copy()
    mov["Fecha"] = pd.to_datetime(mov["Fecha"])
    mov["Mes"] = month_str(mov["Fecha"])
    ingresos = ingresos.copy()
    ingresos["Mes"] = month_str(ingresos["Fecha"])

    results = []
    for mes in sorted(mov["Mes"].unique()):
        inc = ingresos.loc[ingresos["Mes"] == mes, "Monto_Neto"].sum()
        if inc <= 0:
            continue
        half = 0.5 * inc

        m = mov.loc[mov["Mes"] == mes].copy()
        # expenses = negative amounts
        m = m.sort_values("Fecha")
        m["Gasto_Pos"] = (-m["Monto"]).clip(lower=0)
        m["CumGasto"] = m["Gasto_Pos"].cumsum()

        hit = m.loc[m["CumGasto"] >= half]
        if hit.empty:
            continue
        hit_dt = hit.iloc[0]["Fecha"]
        first_dt = m.iloc[0]["Fecha"]
        days = max(1.0, (hit_dt - first_dt).total_seconds() / 86400.0)

        vel = safe_div(inc, days)
        results.append({
            "Mes": mes,
            "Ingreso_Mes": inc,
            "Dias_hasta_50pct": days,
            "Velocidad": vel,
            "Fecha_50pct": hit_dt
        })
    return pd.DataFrame(results)


def opportunity_cost_table(gv: pd.DataFrame, rate_annual=0.08, years=10, threshold=200.0):
    gv = gv.copy()
    gv = gv.loc[gv["Monto"] >= threshold].copy()
    if gv.empty:
        return gv.assign(Costo_Oportunidad=0.0)

    r = rate_annual
    fv_mult = (1 + r) ** years
    gv["Costo_Oportunidad"] = gv["Monto"] * fv_mult - gv["Monto"]
    gv["Valor_Futuro"] = gv["Monto"] * fv_mult
    return gv.sort_values("Monto", ascending=False)


def net_worth_by_month(data: dict, dfm: pd.DataFrame, a: Assumptions):
    """
    Approx monthly net worth:
    - Cash: use last Saldo_Acumulado from Movimientos per month
    - Investments: sum of lots purchased up to month, marked at current Valor_Actual (approx)
    - Assets "bienes": constant user input
    - Liabilities: loans estimated using Pagos_Deudas saldo_after min before month end; cards constant
    """
    mov = data["Movimientos_Consolidados"].copy()
    mov["Fecha"] = pd.to_datetime(mov["Fecha"])
    mov["Mes"] = month_str(mov["Fecha"])

    # Cash end-of-month from Saldo_Acumulado
    cash_m = mov.sort_values("Fecha").groupby("Mes")["Saldo_Acumulado"].last()

    inv = data["Inversiones"].copy()
    inv["Fecha_Inversi√≥n"] = pd.to_datetime(inv["Fecha_Inversi√≥n"])
    inv["Mes"] = month_str(inv["Fecha_Inversi√≥n"])
    # Approx: for each month, include all investments up to that month, sum current value
    inv = inv.sort_values("Fecha_Inversi√≥n")
    months = sorted(dfm["Mes"].unique())
    inv_val_m = {}
    for m in months:
        inv_val_m[m] = float(inv.loc[inv["Mes"] <= m, "Valor_Actual"].sum()) if "Valor_Actual" in inv.columns else 0.0
    inv_val_m = pd.Series(inv_val_m)

    # Liabilities loans by month (using payments schedule)
    deudas = data["Deudas_Prestamos"].copy()
    pagos = data["Pagos_Deudas"].copy()
    pagos["Fecha_Pago"] = pd.to_datetime(pagos["Fecha_Pago"])
    pagos["Mes"] = month_str(pagos["Fecha_Pago"])

    # start with current saldo as fallback
    current_saldo = deudas.set_index("ID_Deuda")["Saldo_Actual"].to_dict() if "Saldo_Actual" in deudas.columns else {}
    loans_m = {}
    for m in months:
        # debt balance approx = min saldo_after for payments up to month, else initial current_saldo
        bal = 0.0
        for debt_id, cur in current_saldo.items():
            paid = pagos.loc[(pagos["ID_Deuda"] == debt_id) & (pagos["Mes"] <= m)]
            if not paid.empty and "Saldo_Despu√©s_Pago" in paid.columns:
                b = float(paid.sort_values("Fecha_Pago")["Saldo_Despu√©s_Pago"].iloc[-1])
            else:
                b = float(cur)
            bal += max(0.0, b)
        loans_m[m] = bal
    loans_m = pd.Series(loans_m)

    cards = data["Tarjetas_Credito"].copy()
    cards_balance = float(cards["Saldo_Actual"].sum()) if "Saldo_Actual" in cards.columns else 0.0

    assets = (cash_m.reindex(months).fillna(method="ffill").fillna(0.0) +
              inv_val_m.reindex(months).fillna(0.0) +
              float(a.bienes_value))

    liabilities = loans_m.reindex(months).fillna(0.0) + cards_balance
    net = assets - liabilities

    out = pd.DataFrame({
        "Mes": months,
        "Activos_Caja": cash_m.reindex(months).fillna(method="ffill").fillna(0.0).values,
        "Activos_Inversiones": inv_val_m.reindex(months).fillna(0.0).values,
        "Activos_Bienes": float(a.bienes_value),
        "Pasivos_Deudas": loans_m.reindex(months).fillna(0.0).values,
        "Pasivos_Tarjetas": cards_balance,
        "Patrimonio_Neto": net.values
    })
    return out


def forecast_net_worth(nw_df: pd.DataFrame, base_savings_monthly: float, years=5, a: Assumptions = None):
    """
    Simple projection:
    - Base: savings stays constant and grows at expected return on investments chunk.
    - Optimistic: +20% income => +20% savings
    - Pessimistic: -20% income => -20% savings (floored)
    """
    a = a or Assumptions()
    last = float(nw_df["Patrimonio_Neto"].iloc[-1]) if len(nw_df) else 0.0
    months = int(years * 12)
    t = np.arange(0, months+1)
    r_m = (1 + a.expected_return_annual) ** (1/12) - 1

    def proj(sav_mult):
        s = max(-1e9, base_savings_monthly * sav_mult)
        values = [last]
        v = last
        for i in range(months):
            # add savings then grow
            v = (v + s) * (1 + r_m)
            values.append(v)
        return values

    out = pd.DataFrame({
        "Mes_Futuro": t,
        "Base": proj(1.0),
        "Optimista": proj(1.2),
        "Pesimista": proj(0.8),
    })
    return out


# ----------------------------
# UI
# ----------------------------
st.title("üìä Finanzas Personales ‚Äî Dashboard & KPIs (Excel ‚Üí Streamlit)")
st.caption("Asesor: App para an√°lisis financiero personal con KPIs, deuda (avalancha vs nieve), runway, scores, y proyecciones.")

with st.sidebar:
    st.header("‚öôÔ∏è Configuraci√≥n")
    uploaded = st.file_uploader("Sube tu Excel (Finanzas_Personales_Analisis_Horario.xlsx)", type=["xlsx"])

    currency_symbol = st.text_input("S√≠mbolo moneda", value="S/ ")
    include_investments_in_cashflow = st.toggle("Incluir inversiones en 'Gastos Totales' (cashflow)", value=False)
    include_debt_payments_in_expenses = st.toggle("Incluir pagos de deuda en 'Gastos Totales'", value=True)

    st.subheader("Supuestos")
    expected_return = st.slider("Retorno esperado anual (para oportunidad/forecast)", 0.0, 0.30, 0.08, 0.005)
    inflation = st.slider("Inflaci√≥n anual (referencial)", 0.0, 0.20, 0.03, 0.005)
    swr = st.slider("Safe Withdraw Rate (jubilaci√≥n)", 0.02, 0.06, 0.04, 0.005)
    bienes = st.number_input("Bienes (valor estimado) ‚Äî opcional", min_value=0.0, value=0.0, step=500.0)
    haircut = st.slider("Haircut liquidaci√≥n inversiones (runway)", 0.0, 1.0, 0.70, 0.05)

    st.subheader("Deuda ‚Äî extra pago")
    extra_debt = st.number_input("Pago extra mensual (adem√°s de m√≠nimos)", min_value=0.0, value=0.0, step=50.0)

    st.subheader("An√°lisis grande (opportunity cost)")
    oc_years = st.slider("A√±os para costo de oportunidad", 1, 30, 10, 1)
    oc_threshold = st.number_input("Umbral gasto grande (>=)", min_value=0.0, value=200.0, step=50.0)

    st.subheader("Runway")
    runway_invest = st.toggle("Runway: incluir inversiones (con haircut)", value=False)


if not uploaded:
    st.info("Asesor: sube el Excel para empezar.")
    st.stop()

# Load
try:
    data = load_excel(uploaded)
except Exception as e:
    st.error(f"Asesor: no pude cargar el Excel. Detalle: {e}")
    st.stop()

ass = Assumptions(
    currency_symbol=currency_symbol,
    include_investments_in_cashflow=include_investments_in_cashflow,
    include_debt_payments_in_expenses=include_debt_payments_in_expenses,
    expected_return_annual=expected_return,
    inflation_annual=inflation,
    swr=swr,
    extra_debt_payment_monthly=extra_debt,
    bienes_value=bienes,
    invest_liquidation_haircut=haircut,
    runway_include_investments=runway_invest
)

dfm, mov, ingresos, gf, gv, pagos, inv = build_monthly_table(data, ass)
ratios = compute_ratios_and_balance(data, dfm, ass)
health_score = compute_health_score(dfm, ratios, data)
runway_normal, runway_survival, runway_with_liq, burn_normal, burn_survival = compute_runway(ratios, dfm, ass)

# Money velocity
mv_df = compute_money_velocity(mov, ingresos)

# Net worth series + forecast
nw_df = net_worth_by_month(data, dfm, ass)
base_sav = float(dfm["Flujo_Neto"].tail(3).mean()) if len(dfm) else 0.0
forecast_df = forecast_net_worth(nw_df, base_sav, years=5, a=ass)

# Debt simulations
debts_universe = build_debt_universe(data)
sch_av, int_av, months_av = simulate_payoff(debts_universe, extra_payment=ass.extra_debt_payment_monthly, strategy="avalanche")
sch_sn, int_sn, months_sn = simulate_payoff(debts_universe, extra_payment=ass.extra_debt_payment_monthly, strategy="snowball")
sch_hy, int_hy, months_hy = simulate_payoff(debts_universe, extra_payment=ass.extra_debt_payment_monthly, strategy="hybrid")

# Opportunity cost
oc_tbl = opportunity_cost_table(gv, rate_annual=ass.expected_return_annual, years=oc_years, threshold=oc_threshold)


# ----------------------------
# Top KPIs row
# ----------------------------
c1, c2, c3, c4, c5 = st.columns(5)

c1.metric("Patrimonio Neto (actual)", money(ratios["patrimonio_neto_actual"], ass.currency_symbol))
c2.metric("Tasa de Ahorro (global)", f"{ratios['tasa_ahorro_global']*100:.1f}%")
c3.metric("Liquidez (meses)", f"{ratios['ratio_liquidez']:.1f}")
c4.metric("Deuda/Ingresos (anual)", f"{ratios['ratio_deuda_ingresos']*100:.1f}%")
c5.metric("Health Score (0-1000)", f"{health_score}")

st.divider()


# ----------------------------
# Tabs
# ----------------------------
tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs([
    "üìå Dashboard",
    "üí∏ Flujo de caja + FCF",
    "üè¶ Ratios + Patrimonio",
    "üí≥ Deudas (estrategias)",
    "üß† An√°lisis avanzados",
    "üîÆ Proyecciones & sensibilidad"
])

# ----------------------------
# Tab 1 ‚Äî Dashboard
# ----------------------------
with tab1:
    st.subheader("Dashboard principal")

    # Waterfall: Ingresos vs Gastos (√∫ltimo mes)
    last_month = dfm["Mes"].iloc[-1] if len(dfm) else None
    if last_month:
        row = dfm.loc[dfm["Mes"] == last_month].iloc[0]
        wf = go.Figure(go.Waterfall(
            x=["Ingresos", "Gastos Fijos", "Gastos Variables", "Pagos Deuda", "Inversiones", "Flujo Neto"],
            y=[
                row["Ingresos_Netos"],
                -row["Gastos_Fijos"],
                -row["Gastos_Variables"],
                -row["Pagos_Deuda"],
                -row["Inversiones_Outflow"] if ass.include_investments_in_cashflow else 0,
                row["Flujo_Neto"],
            ],
            measure=["relative","relative","relative","relative","relative","total"],
        ))
        wf.update_layout(title=f"Cascada ‚Äî {last_month}", height=380, margin=dict(l=10,r=10,t=40,b=10))
        st.plotly_chart(wf, use_container_width=True)

    # Area: Ingresos vs Gastos
    area_df = dfm[["Mes","Ingresos_Netos","Gastos_Totales"]].copy()
    area_df = area_df.melt(id_vars="Mes", var_name="Tipo", value_name="Monto")
    fig_area = px.area(area_df, x="Mes", y="Monto", color="Tipo", title="Ingresos vs Gastos (mensual)")
    fig_area.update_layout(height=360, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_area, use_container_width=True)

    # Gauge ratios
    g1, g2, g3 = st.columns(3)

    util = ratios["util_credito"]
    fig_g1 = go.Figure(go.Indicator(
        mode="gauge+number",
        value=util*100,
        title={"text":"Utilizaci√≥n de cr√©dito (%)"},
        gauge={"axis":{"range":[0,100]}, "bar":{"color":"#444"}}
    ))
    fig_g1.update_layout(height=260, margin=dict(l=10,r=10,t=40,b=10))
    g1.plotly_chart(fig_g1, use_container_width=True)

    fig_g2 = go.Figure(go.Indicator(
        mode="gauge+number",
        value=ratios["ratio_gastos_fijos"]*100,
        title={"text":"Ratio Gastos Fijos / Ingresos (%)"},
        gauge={"axis":{"range":[0,100]}, "bar":{"color":"#444"}}
    ))
    fig_g2.update_layout(height=260, margin=dict(l=10,r=10,t=40,b=10))
    g2.plotly_chart(fig_g2, use_container_width=True)

    fig_g3 = go.Figure(go.Indicator(
        mode="gauge+number",
        value=ratios["fi_index"],
        title={"text":"FI Index (%)"},
        gauge={"axis":{"range":[0,150]}, "bar":{"color":"#444"}}
    ))
    fig_g3.update_layout(height=260, margin=dict(l=10,r=10,t=40,b=10))
    g3.plotly_chart(fig_g3, use_container_width=True)

    # Net worth line
    fig_nw = px.line(nw_df, x="Mes", y="Patrimonio_Neto", title="Evoluci√≥n de Patrimonio Neto (aprox)")
    fig_nw.update_layout(height=360, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_nw, use_container_width=True)

    st.caption("Asesor: Patrimonio mensual es aproximado porque tarjetas no tienen hist√≥rico y las inversiones usan valor actual como proxy por mes.")


# ----------------------------
# Tab 2 ‚Äî Cashflow + FCF
# ----------------------------
with tab2:
    st.subheader("Flujo de caja, EBITDA personal y Free Cash Flow personal")

    k1, k2, k3, k4 = st.columns(4)
    k1.metric("Ingreso mensual promedio", money(dfm["Ingresos_Netos"].mean(), ass.currency_symbol))
    k2.metric("Gasto mensual promedio", money(dfm["Gastos_Totales"].mean(), ass.currency_symbol))
    k3.metric("Flujo neto mensual promedio", money(dfm["Flujo_Neto"].mean(), ass.currency_symbol))
    k4.metric("EBITDA personal promedio", money(dfm["EBITDA_Personal"].mean(), ass.currency_symbol))

    # Table
    show = dfm[["Mes","Ingresos_Netos","Gastos_Totales","Flujo_Neto","Tasa_Ahorro","EBITDA_Personal","FCF_Personal"]].copy()
    show["Tasa_Ahorro"] = (show["Tasa_Ahorro"]*100).round(1)
    st.dataframe(show, use_container_width=True, hide_index=True)

    # Bars by category (stacked) ‚Äî variable expenses by category
    gv["Mes"] = month_str(gv["Fecha"])
    gv_cat = gv.groupby(["Mes","Categor√≠a"])["Monto"].sum().reset_index()
    fig_stack = px.bar(gv_cat, x="Mes", y="Monto", color="Categor√≠a", title="Gastos Variables por Categor√≠a (barras apiladas)")
    fig_stack.update_layout(height=380, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_stack, use_container_width=True)

    # Heatmap: expenses by day x category
    mov2 = mov.copy()
    mov2["Fecha"] = pd.to_datetime(mov2["Fecha"])
    mov2["Dia"] = mov2["Fecha"].dt.date
    mov2["Gasto_Pos"] = (-mov2["Monto"]).clip(lower=0)
    heat = mov2.groupby(["Dia","Categor√≠a"])["Gasto_Pos"].sum().reset_index()
    if not heat.empty:
        pivot = heat.pivot_table(index="Dia", columns="Categor√≠a", values="Gasto_Pos", aggfunc="sum").fillna(0.0)
        fig_heat = px.imshow(pivot.T, aspect="auto", title="Mapa de calor ‚Äî Gastos por d√≠a y categor√≠a")
        fig_heat.update_layout(height=420, margin=dict(l=10,r=10,t=40,b=10))
        st.plotly_chart(fig_heat, use_container_width=True)

    st.caption("Asesor: El Free Cash Flow personal usa CapEx = Educaci√≥n + Salud (puedes ajustar esa definici√≥n si quieres).")


# ----------------------------
# Tab 3 ‚Äî Ratios + Net Worth Composition
# ----------------------------
with tab3:
    st.subheader("Ratios financieros + composici√≥n patrimonial")

    r1, r2, r3, r4, r5 = st.columns(5)
    r1.metric("Deuda / Ingresos (anual)", f"{ratios['ratio_deuda_ingresos']*100:.1f}%")
    r2.metric("Liquidez (meses)", f"{ratios['ratio_liquidez']:.2f}")
    r3.metric("Gastos fijos / Ingresos", f"{ratios['ratio_gastos_fijos']*100:.1f}%")
    r4.metric("Utilizaci√≥n cr√©dito", f"{ratios['util_credito']*100:.1f}%")
    r5.metric("FI Index", f"{ratios['fi_index']:.1f}%")

    # Composition pie
    pie_assets = pd.DataFrame({
        "Componente": ["Caja (cuentas)", "Inversiones", "Bienes (manual)"],
        "Monto": [ratios["activos_liquidos"], ratios["inversiones_valor"], ass.bienes_value]
    })
    fig_pie = px.pie(pie_assets, names="Componente", values="Monto", title="Composici√≥n de Activos")
    fig_pie.update_layout(height=360, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_pie, use_container_width=True)

    # Net worth breakdown line
    fig_nw2 = px.line(
        nw_df.melt(id_vars="Mes", value_vars=["Activos_Caja","Activos_Inversiones","Pasivos_Deudas","Patrimonio_Neto"],
                   var_name="Serie", value_name="Monto"),
        x="Mes", y="Monto", color="Serie", title="Activos / Pasivos y Patrimonio (mensual aprox)"
    )
    fig_nw2.update_layout(height=380, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_nw2, use_container_width=True)

    # Break-even point stats
    st.subheader("Punto de equilibrio personal (Break-even)")
    # monthly fixed / monthly income
    fixed_avg = float(dfm["Gastos_Fijos"].mean())
    inc_avg = float(dfm["Ingresos_Netos"].mean())
    pct_comp = safe_div(fixed_avg, inc_avg)
    days_work = safe_div(fixed_avg, safe_div(inc_avg, 30.0))
    st.write(
        f"- % ingreso comprometido en gastos fijos: **{pct_comp*100:.1f}%**\n"
        f"- Ingreso m√≠nimo para cubrir fijos (prom): **{money(fixed_avg, ass.currency_symbol)}**\n"
        f"- D√≠as del mes trabajando ‚Äúsolo para obligaciones‚Äù (aprox): **{days_work:.1f} d√≠as**"
    )

    # Runway
    st.subheader("Runway financiero (pista de aterrizaje)")
    runway_display = runway_with_liq if ass.runway_include_investments else runway_normal
    st.write(
        f"- Burn rate normal (prom): **{money(burn_normal, ass.currency_symbol)}/mes**\n"
        f"- Burn rate supervivencia (esenciales): **{money(burn_survival, ass.currency_symbol)}/mes**\n"
        f"- Runway normal: **{runway_normal:.1f} meses**\n"
        f"- Runway supervivencia: **{runway_survival:.1f} meses**\n"
        f"- Runway con liquidaci√≥n inversiones (haircut {ass.invest_liquidation_haircut:.0%}): **{runway_with_liq:.1f} meses**"
    )


# ----------------------------
# Tab 4 ‚Äî Debt analysis & strategies
# ----------------------------
with tab4:
    st.subheader("An√°lisis de deudas (incluye avalancha vs bola de nieve vs h√≠brido)")

    # Debt total + monthly interest paid
    pagos2 = data["Pagos_Deudas"].copy()
    pagos2["Mes"] = month_str(pagos2["Fecha_Pago"])
    interest_m = pagos2.groupby("Mes")["Monto_Intereses"].sum().reset_index()
    st.metric("Deuda total (deudas + tarjetas)", money(ratios["pasivos_totales"], ass.currency_symbol))

    fig_int = px.bar(interest_m, x="Mes", y="Monto_Intereses", title="Costo financiero mensual (intereses pagados)")
    fig_int.update_layout(height=330, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_int, use_container_width=True)

    st.subheader("Comparaci√≥n de estrategias (con tus saldos actuales)")
    cA, cB, cC = st.columns(3)
    cA.metric("Avalancha ‚Äî inter√©s total", money(int_av, ass.currency_symbol))
    cB.metric("Bola de nieve ‚Äî inter√©s total", money(int_sn, ass.currency_symbol))
    cC.metric("H√≠brido ‚Äî inter√©s total", money(int_hy, ass.currency_symbol))

    cA2, cB2, cC2 = st.columns(3)
    cA2.metric("Avalancha ‚Äî meses a pagar", f"{months_av}")
    cB2.metric("Bola de nieve ‚Äî meses a pagar", f"{months_sn}")
    cC2.metric("H√≠brido ‚Äî meses a pagar", f"{months_hy}")

    # Plot payoff balances over time for each strategy (sum of balances)
    def sum_balances(sch):
        b = sch.loc[sch["type"] == "balance"].copy()
        if "balance_end" not in b.columns:
            return pd.DataFrame()
        b = b.groupby("month")["balance_end"].sum().reset_index()
        return b

    bal_av = sum_balances(sch_av).rename(columns={"balance_end":"Avalancha"})
    bal_sn = sum_balances(sch_sn).rename(columns={"balance_end":"Nieve"})
    bal_hy = sum_balances(sch_hy).rename(columns={"balance_end":"Hibrido"})

    merged = bal_av.merge(bal_sn, on="month", how="outer").merge(bal_hy, on="month", how="outer").fillna(method="ffill").fillna(0.0)
    fig_pay = px.line(merged.melt(id_vars="month", var_name="Estrategia", value_name="Saldo"),
                      x="month", y="Saldo", color="Estrategia", title="Timeline de deuda (saldo total) ‚Äî Gantt/curva de pago")
    fig_pay.update_layout(height=380, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_pay, use_container_width=True)

    st.caption("Asesor: El simulador asume pago m√≠nimo fijo + tu 'pago extra mensual'. Si quieres, lo expandimos a pagos variables por mes.")


# ----------------------------
# Tab 5 ‚Äî Advanced analyses
# ----------------------------
with tab5:
    st.subheader("An√°lisis novedosos y potentes")

    # Spending efficiency & zombie spend
    st.markdown("### 4) Spending Efficiency (heur√≠stico) + Gastos zombis")
    # Zombie spend: subscriptions in fixed + variable 'Suscripci√≥n extra'
    zf = gf.loc[gf["Categor√≠a"].astype(str).str.lower().str.contains("suscrip")]
    zv = gv.loc[gv["Subcategor√≠a"].astype(str).str.lower().str.contains("suscrip") | gv["Descripci√≥n"].astype(str).str.lower().str.contains("suscrip")]
    z = pd.concat([zf.assign(Tipo="Fijo", Fecha=zf["Fecha_Cargo"], Monto=zf["Monto"], Desc=zf["Descripci√≥n"], Cat=zf["Categor√≠a"]),
                   zv.assign(Tipo="Variable", Fecha=zv["Fecha"], Monto=zv["Monto"], Desc=zv["Descripci√≥n"], Cat=zv["Categor√≠a"])],
                  ignore_index=True, sort=False)
    z = z[["Tipo","Fecha","Cat","Desc","Monto"]].sort_values("Fecha")
    st.write(f"Gastos 'zombi' detectados (suscripciones): **{len(z)}**")
    st.dataframe(z, use_container_width=True, hide_index=True)

    # CPH: cost per happiness (simple: user assigns happiness 1..10 by category; default 6)
    st.markdown("### Costo por Felicidad (CPH) ‚Äî por categor√≠a (editable)")
    cats = sorted(gv["Categor√≠a"].dropna().unique().tolist())
    default_h = {c: 6 for c in cats}
    default_v = {c: 6 for c in cats}

    colL, colR = st.columns(2)
    with colL:
        st.caption("Happiness (1‚Äì10): cu√°nto disfrutas gastar ah√≠.")
        hvals = {}
        for c in cats[:len(cats)//2 + 1]:
            hvals[c] = st.slider(f"Happiness ‚Äî {c}", 1, 10, default_h[c], 1, key=f"h_{c}")
    with colR:
        st.caption("Valor largo plazo (1‚Äì10): qu√© tanto te aporta a futuro.")
        vvals = {}
        for c in cats[len(cats)//2 + 1:]:
            vvals[c] = st.slider(f"Valor ‚Äî {c}", 1, 10, default_v[c], 1, key=f"v_{c}")

    # Merge missing (if any)
    for c in cats:
        if c not in hvals: hvals[c] = default_h[c]
        if c not in vvals: vvals[c] = default_v[c]

    gv_cat_sum = gv.groupby("Categor√≠a")["Monto"].sum().reset_index()
    gv_cat_sum["Happiness"] = gv_cat_sum["Categor√≠a"].map(hvals).astype(float)
    gv_cat_sum["Valor"] = gv_cat_sum["Categor√≠a"].map(vvals).astype(float)
    gv_cat_sum["CPH"] = gv_cat_sum.apply(lambda r: safe_div(r["Monto"], r["Happiness"]), axis=1)
    gv_cat_sum["ROI_Largo_Plazo_Proxy"] = gv_cat_sum.apply(lambda r: r["Valor"] - (r["CPH"] / (gv_cat_sum["CPH"].mean()+1e-9))*2, axis=1)

    st.dataframe(gv_cat_sum.sort_values("Monto", ascending=False), use_container_width=True, hide_index=True)

    # Matrix of value (x) vs happiness (y) with quadrants
    fig_sc = px.scatter(gv_cat_sum, x="Valor", y="Happiness", size="Monto", hover_name="Categor√≠a",
                        title="Matriz de valor (x) vs felicidad (y)")
    fig_sc.update_layout(height=420, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_sc, use_container_width=True)

    # Risk exposure
    st.markdown("### 6) Exposici√≥n al riesgo (resumen)")
    # income single source risk: top category share
    inc_by_cat = ingresos.groupby("Categor√≠a")["Monto_Neto"].sum()
    top_share = safe_div(inc_by_cat.max(), inc_by_cat.sum())
    debt_payment_ratio = safe_div(dfm["Pagos_Deuda"].sum(), dfm["Ingresos_Netos"].sum())
    lifestyle_inflation = 0.0
    if len(dfm) >= 3:
        # slope comparison: expenses vs income
        x = np.arange(len(dfm))
        inc_slope = np.polyfit(x, dfm["Ingresos_Netos"].values, 1)[0]
        exp_slope = np.polyfit(x, dfm["Gastos_Totales"].values, 1)[0]
        lifestyle_inflation = safe_div(exp_slope, abs(inc_slope) + 1e-9)

    st.write(
        f"- Riesgo de ingreso √∫nico (share mayor fuente): **{top_share*100:.1f}%**\n"
        f"- Riesgo de deuda (pagos deuda / ingresos): **{debt_payment_ratio*100:.1f}%**\n"
        f"- Riesgo de liquidez (meses de cobertura): **{ratios['ratio_liquidez']:.1f}**\n"
        f"- Inflaci√≥n de estilo de vida (tendencia gastos / tendencia ingresos): **{lifestyle_inflation:.2f}** (heur√≠stico)"
    )

    # Opportunity cost
    st.markdown("### 7) Costo de oportunidad (gastos grandes)")
    if oc_tbl.empty:
        st.info("No hay gastos variables por encima del umbral configurado.")
    else:
        cols = ["Fecha","Categor√≠a","Subcategor√≠a","Monto","Valor_Futuro","Costo_Oportunidad"]
        tmp = oc_tbl.copy()
        tmp["Fecha"] = tmp["Fecha"].dt.date
        st.dataframe(tmp[cols].head(50), use_container_width=True, hide_index=True)
        fig_oc = px.bar(tmp.head(20), x="Monto", y="Descripci√≥n", orientation="h",
                        title=f"Top gastos grandes (>= {money(oc_threshold, ass.currency_symbol)}) ‚Äî referencia")
        fig_oc.update_layout(height=520, margin=dict(l=10,r=10,t=40,b=10))
        st.plotly_chart(fig_oc, use_container_width=True)

    # Money velocity
    st.markdown("### 8) Money Velocity (cu√°n r√°pido gastas lo que ganas)")
    if mv_df.empty:
        st.info("No se pudo calcular money velocity (revisa ingresos por mes).")
    else:
        mv_show = mv_df.copy()
        mv_show["Ingreso_Mes"] = mv_show["Ingreso_Mes"].map(lambda x: money(x, ass.currency_symbol))
        mv_show["Velocidad"] = mv_df["Velocidad"].round(2)
        mv_show["Dias_hasta_50pct"] = mv_df["Dias_hasta_50pct"].round(1)
        st.dataframe(mv_show[["Mes","Ingreso_Mes","Dias_hasta_50pct","Velocidad","Fecha_50pct"]], use_container_width=True, hide_index=True)
        fig_mv = px.line(mv_df, x="Mes", y="Dias_hasta_50pct", title="D√≠as hasta gastar 50% del ingreso (por mes)")
        fig_mv.update_layout(height=320, margin=dict(l=10,r=10,t=40,b=10))
        st.plotly_chart(fig_mv, use_container_width=True)

    # FI index categories
    st.markdown("### 10) FI Index (indicador de independencia financiera)")
    st.write(
        f"Ingreso pasivo mensual (prom): **{money(ratios['passive_monthly'], ass.currency_symbol)}**\n\n"
        f"FI Index = (Ingreso pasivo / Gastos mensuales) √ó 100 = **{ratios['fi_index']:.1f}%**"
    )


# ----------------------------
# Tab 6 ‚Äî Projections & sensitivity
# ----------------------------
with tab6:
    st.subheader("Proyecciones, metas y escenarios")

    # Savings projection 6/12
    st.markdown("### Proyecci√≥n de ahorro (6 / 12 meses)")
    avg_flow = float(dfm["Flujo_Neto"].tail(3).mean()) if len(dfm) else 0.0
    proj6 = avg_flow * 6
    proj12 = avg_flow * 12
    c1, c2 = st.columns(2)
    c1.metric("Ahorro proyectado 6 meses (prom √∫ltimos 3)", money(proj6, ass.currency_symbol))
    c2.metric("Ahorro proyectado 12 meses (prom √∫ltimos 3)", money(proj12, ass.currency_symbol))

    # Goals time-to-target
    st.markdown("### Tiempo para metas financieras")
    metas = data["Metas_Financieras"].copy()
    metas["Restante"] = (metas["Monto_Objetivo"] - metas["Monto_Acumulado"]).clip(lower=0)
    metas["Meses_estimados"] = metas.apply(lambda r: math.ceil(safe_div(r["Restante"], r["Aporte_Mensual_Planeado"])) if r["Aporte_Mensual_Planeado"]>0 else np.nan, axis=1)
    st.dataframe(metas[["Nombre_Meta","Categor√≠a","Monto_Objetivo","Monto_Acumulado","Restante","Aporte_Mensual_Planeado","Meses_estimados","Prioridad","Estado"]],
                 use_container_width=True, hide_index=True)

    fig_goals = px.line(
        metas.assign(Porcentaje=metas["Porcentaje_Completado"]*100),
        x="Nombre_Meta", y="Porcentaje", markers=True, title="Progreso de metas (%)"
    )
    fig_goals.update_layout(height=320, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_goals, use_container_width=True)

    # Forecast net worth scenarios (1,5,10,20 years) ‚Äî show 5-year curve
    st.markdown("### Forecast de patrimonio neto (3 escenarios) ‚Äî 5 a√±os")
    fig_fc = px.line(forecast_df.melt(id_vars="Mes_Futuro", var_name="Escenario", value_name="Patrimonio"),
                     x="Mes_Futuro", y="Patrimonio", color="Escenario", title="Patrimonio neto proyectado (mensual)")
    fig_fc.update_layout(height=380, margin=dict(l=10,r=10,t=40,b=10))
    st.plotly_chart(fig_fc, use_container_width=True)

    # Retirement projection (rough)
    st.markdown("### Jubilaci√≥n ‚Äî referencia r√°pida (muy pr√°ctico)")
    exp_month = st.number_input("Gasto mensual objetivo en jubilaci√≥n (referencia)", min_value=0.0, value=float(ratios["gasto_mensual_prom"]), step=100.0)
    needed_capital = safe_div(exp_month*12, ass.swr)  # capital needed for annual spending at SWR
    st.write(
        f"- Capital estimado necesario (SWR {ass.swr:.0%}): **{money(needed_capital, ass.currency_symbol)}**\n"
        f"- Patrimonio actual: **{money(ratios['patrimonio_neto_actual'], ass.currency_symbol)}**\n"
        f"- Brecha estimada: **{money(max(0.0, needed_capital - ratios['patrimonio_neto_actual']), ass.currency_symbol)}**"
    )

    # Sensitivity analysis
    st.markdown("### 12) An√°lisis de sensibilidad (what-if)")
    s1, s2, s3 = st.columns(3)
    job_loss_months = s1.slider("P√©rdida de empleo (meses)", 0, 12, 6, 1)
    emergency_cost = s2.number_input("Emergencia m√©dica (monto)", min_value=0.0, value=10000.0, step=500.0)
    rate_shock = s3.slider("Shock tasa inter√©s mensual (tarjetas) +", 0.0, 0.05, 0.01, 0.005)

    liquid = ratios["activos_liquidos"]
    runway_after_jobloss = safe_div(liquid, burn_survival)  # survival runway (months)
    liquid_after_emergency = max(0.0, liquid - emergency_cost)
    runway_after_emergency = safe_div(liquid_after_emergency, burn_survival)

    # debt interest shock approximation
    tarjetas = data["Tarjetas_Credito"].copy()
    shock_cost = float((tarjetas["Saldo_Actual"] * rate_shock).sum()) if not tarjetas.empty else 0.0

    st.write(
        f"- Runway supervivencia actual: **{runway_survival:.1f} meses**\n"
        f"- Si pierdes el trabajo {job_loss_months} meses: recomendado tener runway >= {job_loss_months}. Tu runway: **{runway_survival:.1f}**\n"
        f"- Si ocurre emergencia de {money(emergency_cost, ass.currency_symbol)}: runway baja a **{runway_after_emergency:.1f} meses**\n"
        f"- Shock de tasa tarjetas +{rate_shock*100:.1f}% mensual ‚âà costo extra mensual: **{money(shock_cost, ass.currency_symbol)}**"
    )

    # Goal acceleration
    st.markdown("### 13) Aceleraci√≥n de objetivos (10% + ahorro / - gastos)")
    delta = 0.10
    cur_save = max(0.0, avg_flow)
    save_plus = cur_save * (1 + delta)
    spend_minus_effect = cur_save + (ratios["gasto_mensual_prom"] * delta)  # if reduce spend 10%, savings increase
    both = save_plus + (ratios["gasto_mensual_prom"] * delta)

    # Pick one meta to showcase
    meta_names = metas["Nombre_Meta"].tolist() if len(metas) else ["(sin metas)"]
    chosen = st.selectbox("Meta a evaluar", meta_names, index=0)
    if len(metas) and chosen in metas["Nombre_Meta"].values:
        r = metas.loc[metas["Nombre_Meta"] == chosen].iloc[0]
        remaining = float(r["Restante"])

        def months_to_goal(monthly_add):
            return math.ceil(safe_div(remaining, monthly_add)) if monthly_add > 0 else np.inf

        m0 = months_to_goal(max(1e-9, cur_save))
        m1 = months_to_goal(max(1e-9, save_plus))
        m2 = months_to_goal(max(1e-9, spend_minus_effect))
        m3 = months_to_goal(max(1e-9, both))

        st.write(
            f"- Tiempo actual: **{m0} meses**\n"
            f"- Si aumentas ahorro 10%: **{m1} meses** (Œî {(m0-m1)} meses)\n"
            f"- Si reduces gastos 10%: **{m2} meses** (Œî {(m0-m2)} meses)\n"
            f"- Si haces ambos: **{m3} meses** (Œî {(m0-m3)} meses)"
        )

    # Tax efficiency quick view
    st.markdown("### 14) Eficiencia fiscal (b√°sico con tu data)")
    ing = data["Ingresos"].copy()
    tax_paid = float(ing["Impuestos_Retenciones"].sum()) if "Impuestos_Retenciones" in ing.columns else 0.0
    gross = float(ing["Monto_Bruto"].sum()) if "Monto_Bruto" in ing.columns else 0.0
    eff_tax = safe_div(tax_paid, gross)
    st.write(
        f"- Impuestos/retenciones registradas: **{money(tax_paid, ass.currency_symbol)}**\n"
        f"- Ingreso bruto total: **{money(gross, ass.currency_symbol)}**\n"
        f"- Tasa efectiva aproximada: **{eff_tax*100:.1f}%**"
    )

st.divider()
st.caption("Asesor: si quieres, en el siguiente paso lo dejamos 100% 'auditable': exporta una hoja nueva con todos los KPIs calculados y otra con el detalle de cada f√≥rmula/definici√≥n.")